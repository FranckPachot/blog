<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Where to check Data Guard gap?</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Where to check Data Guard gap?</h1>
</header>
<section data-field="subtitle" class="p-summary">
At work, we had a discussion with well-known colleagues, Luca Canali and Ludovico Caldara, about where we check that Data Guard recovery…
</section>
<section data-field="body" class="e-content">
<section name="8210" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="95aa" id="95aa" class="graf graf--h3 graf--leading graf--title">Where to check Data Guard gap?</h3><p name="85a9" id="85a9" class="graf graf--p graf-after--h3">At work, we had a discussion with well-known colleagues, Luca Canali and Ludovico Caldara, about where we check that Data Guard recovery works as expected without gap. Several views can be queried, depending on the context. Here are a few comments about them.</p><h3 name="8be7" id="8be7" class="graf graf--h3 graf-after--p">v$database</h3><p name="60df" id="60df" class="graf graf--p graf-after--h3">This is my preferred because it relies on the actual state of the database, whatever the recovery process is:</p><pre name="567c" id="567c" class="graf graf--pre graf-after--p">SQL&gt; select scn_to_timestamp(current_scn) <br>     from v$database;</pre><pre name="12fe" id="12fe" class="graf graf--pre graf-after--pre">SCN_TO_TIMESTAMP(CURRENT_SCN)<br>----------------------------------------------------------<br>22-JAN-19 03.08.32.000000000 PM</pre><p name="a335" id="a335" class="graf graf--p graf-after--pre">This reads the current System Change number (DICUR_SCN from X$KCCDI) and maps it to a timestamp (using the mapping SMON_SCN_TIME table).</p><p name="2dfe" id="2dfe" class="graf graf--p graf-after--p">However, relying on a function which is available only when the database is opened, this is easy only with Active Data Guard. When the database is in mount state, you will get <em class="markup--em markup--p-em">ORA-00904: “SCN_TO_TIMESTAMP”: invalid identifier</em>.</p><p name="f01f" id="f01f" class="graf graf--p graf-after--p">Note that I’ve also seen cases where, in case of gap, the SMON_SCN_TIME was not up-to-date and I got <em class="markup--em markup--p-em">ORA-08181: specified number is not a valid system change number</em>. Then this is not for automatic monitoring.</p><p name="3410" id="3410" class="graf graf--p graf-after--p">Without Active Data Guard, you need to do the SCN to timestamp conversion on the primary. Or read the SCN from the datafiles, but this is not the latest apply but the lastest checkpointed:</p><pre name="a4e2" id="a4e2" class="graf graf--pre graf-after--p">SQL&gt; alter session set nls_date_format=&#39;dd-mm-yy hh24:mi:ss&#39;;<br>Session altered.</pre><pre name="42f5" id="42f5" class="graf graf--pre graf-after--pre">SQL&gt; select max(checkpoint_time) from v$datafile_header;<br>MAX(CHECKPOINT_TI<br>-----------------<br>26-01-19 17:45:04</pre><p name="0bfa" id="0bfa" class="graf graf--p graf-after--pre">Reading from V$DATABASE does not rely on Data Guard and then is also available when the MRP is not started and also in Standard Edition non-managed standby.</p><h3 name="74d2" id="74d2" class="graf graf--h3 graf-after--p">gv$recovery_progress</h3><p name="9fe4" id="9fe4" class="graf graf--p graf-after--h3">This is Luca’s favored one (see is adg.sql script among many other interesting ones in <a href="https://github.com/LucaCanali/Oracle_DBA_scripts" data-href="https://github.com/LucaCanali/Oracle_DBA_scripts" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/LucaCanali/Oracle_DBA_scripts</a>):</p><pre name="8d55" id="8d55" class="graf graf--pre graf-after--p">SQL&gt; select inst_id, max(timestamp) <br>     from gv$recovery_progress group by inst_id;</pre><pre name="d6aa" id="d6aa" class="graf graf--pre graf-after--pre">INST_ID MAX(TIMESTAMP)<br>---------- --------------------<br>         1 22-JAN-2019 15:08:51</pre><p name="7c7a" id="7c7a" class="graf graf--p graf-after--pre">Where does this information come from? If you look at the execution plan you will see that it reads X$KSULOP which is the X$ that is behind V$SESSION_LONGOPS. You can get the same timestamp from it:</p><pre name="8294" id="8294" class="graf graf--pre graf-after--p">SQL&gt; alter session set nls_date_format=&#39;dd-mm-yy hh24:mi:ss&#39;;<br>Session altered.</pre><pre name="7573" id="7573" class="graf graf--pre graf-after--pre">SQL&gt; select inst_id,opname,timestamp from gv$session_longops <br>where opname=&#39;Media Recovery&#39; and target_desc=&#39;Last Applied Redo&#39;;</pre><pre name="f16a" id="f16a" class="graf graf--pre graf-after--pre">INST_ID OPNAME               TIMESTAMP<br>---------- -------------------- -----------------<br>         1 Media Recovery       26-01-19 18:56:39<br>         1 Media Recovery       26-01-19 19:40:35</pre><p name="0ccb" id="0ccb" class="graf graf--p graf-after--pre">As this information comes from what the MRP (Managed Recovery Process) logs, this view is available only when the recovery is running (APPLY-ON).</p><h3 name="d9f0" id="d9f0" class="graf graf--h3 graf-after--p">v$managed_standby;</h3><p name="baef" id="baef" class="graf graf--p graf-after--h3">Talking about what is logged by MRP, Ludo goes to the MRP status in v$managed_standby to see the sequence and block# increase. This is very interesting as we can compare the remaining work to do, from what is received by RFS:</p><pre name="f452" id="f452" class="graf graf--pre graf-after--p">19:59:46 SQL&gt; select inst_id,process,status,client_process,thread#,sequence#,block#,blocks from gv$managed_standby;</pre><pre name="3879" id="3879" class="graf graf--pre graf-after--pre">I PROCESS   STATUS       CLIENT_P THREAD# SEQUENCE# BLOCK# BLOCKS<br>- --------- ------------ -------- ------- --------- ------ ------<br>1 ARCH      CLOSING      ARCH           1        34  32768    481<br>1 DGRD      ALLOCATED    N/A            0         0      0      0<br>1 DGRD      ALLOCATED    N/A            0         0      0      0<br>1 ARCH      CLOSING      ARCH           1        41  28672   2046<br>1 ARCH      CLOSING      ARCH           1        37  30720   1804<br>1 ARCH      CLOSING      ARCH           1        40  26624   1608<br>1 RFS       IDLE         Archival       1         0      0      0<br>1 RFS       IDLE         UNKNOWN        0         0      0      0<br>1 RFS       IDLE         LGWR           1        42    121      1<br>1 RFS       IDLE         UNKNOWN        0         0      0      0<br>1 MRP0      APPLYING_LOG N/A            1        42    121  40960</pre><pre name="c62b" id="c62b" class="graf graf--pre graf-after--pre">11 rows selected.</pre><pre name="56df" id="56df" class="graf graf--pre graf-after--pre">19:59:50 SQL&gt; /</pre><pre name="0661" id="0661" class="graf graf--pre graf-after--pre">I PROCESS   STATUS       CLIENT_P THREAD# SEQUENCE# BLOCK# BLOCKS<br>- --------- ------------ -------- ------- --------- ------ ------<br>1 ARCH      CLOSING      ARCH           1        34  32768    481<br>1 DGRD      ALLOCATED    N/A            0         0      0      0<br>1 DGRD      ALLOCATED    N/A            0         0      0      0<br>1 ARCH      CLOSING      ARCH           1        41  28672   2046<br>1 ARCH      CLOSING      ARCH           1        37  30720   1804<br>1 ARCH      CLOSING      ARCH           1        40  26624   1608<br>1 RFS       IDLE         Archival       1         0      0      0<br>1 RFS       IDLE         UNKNOWN        0         0      0      0<br>1 RFS       IDLE         LGWR           1        42    124      1<br>1 RFS       IDLE         UNKNOWN        0         0      0      0<br>1 MRP0      APPLYING_LOG N/A            1        42    124  40960</pre><pre name="8f05" id="8f05" class="graf graf--pre graf-after--pre">11 rows selected.</pre><h3 name="c150" id="c150" class="graf graf--h3 graf-after--pre">v$archived_log</h3><p name="f90b" id="f90b" class="graf graf--p graf-after--h3">V$ARCHIVED_LOG has an ‘APPLIED’ flag, but it is not really helpful here as it does not consider the real-time apply. In the following screenshot the changes up to 20:35:46 in sequence# 55 have been applied but V$ARCHIVED_LOG shows sequence 52 as not applied:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="f58f" id="f58f" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 519px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50.3%;"></div><img class="graf-image" data-image-id="1*787Ef-XiXm3BvFhDsurwZg.png" data-width="2692" data-height="1355" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*787Ef-XiXm3BvFhDsurwZg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="da81" id="da81" class="graf graf--p graf-after--figure">This view is about archived logs. But before being archived, the redo stream is received to the standby logs.</p><h3 name="d540" id="d540" class="graf graf--h3 graf-after--p">v$standby_log</h3><p name="e9d0" id="e9d0" class="graf graf--p graf-after--h3">With real-time apply (RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE) the redo is applied as soon as it is received in the standby redo logs. The gap should be small and is visible in v$managed_standby (number of blocks between RFS from LGWR and MRP apply). I’ve seen some monitoring queries on V$STANDBY_LOG. The idea is to read the actual state of the transport, in the same idea that when I read V$DATABASE for the actual state of apply, without relying on what is logged by the processes:</p><pre name="4bc6" id="4bc6" class="graf graf--pre graf-after--p">SQL&gt; select max(last_time) <br>     from gv$standby_log;</pre><pre name="d45c" id="d45c" class="graf graf--pre graf-after--pre">MAX(LAST_TIME)<br>--------------------<br>22-JAN-2019 15:08:55</pre><p name="3941" id="3941" class="graf graf--p graf-after--pre">However, this query reads X$KCCSL which is not very efficient as it reads the standby redo log files. This can be long when they are large and full:</p><figure name="e6a7" id="e6a7" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 87px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 12.4%;"></div><img class="graf-image" data-image-id="1*Hy1F8jOD87LTkM2hFrtQeA.png" data-width="909" data-height="113" src="https://cdn-images-1.medium.com/max/800/1*Hy1F8jOD87LTkM2hFrtQeA.png"></div></figure><p name="3776" id="3776" class="graf graf--p graf-after--figure">So… be careful with this one.</p><h3 name="a438" id="a438" class="graf graf--h3 graf-after--p">v$dataguard_stats</h3><p name="def1" id="def1" class="graf graf--p graf-after--h3">The DG Broker ‘show database’ displays the gap information. This comes from V$DATAGUARD_STATS as Data Guard checks the state at regular interval and stores the latest here:</p><pre name="1af4" id="1af4" class="graf graf--pre graf-after--p">SQL&gt; select name||&#39; &#39;||value ||&#39; &#39;|| unit<br>     ||&#39; computed at &#39;||time_computed <br>     from v$dataguard_stats;</pre><pre name="bae5" id="bae5" class="graf graf--pre graf-after--pre">NAME||&#39;&#39;||VALUE||&#39;&#39;||UNIT||&#39;COMPUTEDAT&#39;||TIME_COMPUTED<br>------------------------------------------------------</pre><pre name="06e9" id="06e9" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">transport lag</strong> +00 00:00:00 day(2) to second(0) interval computed at 01/27/2019 22:08:33</pre><pre name="38dc" id="38dc" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">apply lag</strong> +00 00:00:01 day(2) to second(0) interval computed at 01/27/2019 22:08:33</pre><pre name="d192" id="d192" class="graf graf--pre graf-after--pre">apply finish time +00 00:00:06.493 day(2) to second(3) interval computed at 01/27/2019 22:08:33</pre><p name="62ed" id="62ed" class="graf graf--p graf-after--pre">You must always check when the value was calculated (TIME_COMPUTED) and may add this to gap to estimate the gap from the current time, as with DGMGRL:</p><pre name="5f9f" id="5f9f" class="graf graf--pre graf-after--p graf--trailing">Role:               PHYSICAL STANDBY<br>  Intended State:     APPLY-ON<br>  Transport Lag:      0 seconds (computed 1 second ago)<br>  Apply Lag:          1 second (computed 1 second ago)<br>  Average Apply Rate: 0 Byte/s<br>  Real Time Query:    OFF<br>  Instance(s):<br>    CDB2</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/e1ccadc8f41"><time class="dt-published" datetime="2019-01-27T21:22:31.625Z">January 27, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/where-to-check-data-guard-gap-e1ccadc8f41" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>