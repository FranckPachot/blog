<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Running pgBench on YugaByteDB 1.3</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Running pgBench on YugaByteDB 1.3</h1>
</header>
<section data-field="subtitle" class="p-summary">
My first test on this Open Source SQL distributed database.
</section>
<section data-field="body" class="e-content">
<section name="6eee" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2664" id="2664" class="graf graf--h3 graf--leading graf--title">Running pgBench on YugaByte DB 1.3</h3><h4 name="f245" id="f245" class="graf graf--h4 graf-after--h3 graf--subtitle">My first test on this Open Source SQL distributed database.</h4><p name="e020" id="e020" class="graf graf--p graf-after--h4">Did you hear about <a href="https://docs.yugabyte.com/latest/introduction/" data-href="https://docs.yugabyte.com/latest/introduction/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">YugaByteDB</a>, a distributed database with an architecture similar to Google Spanner, using PostgreSQL as the query layer?</p><p name="7e47" id="7e47" class="graf graf--p graf-after--p">I started to follow when I’ve heard that Bryn Llewellyn, famous PL/SQL and EBR product manager, left Oracle to be their developer advocate. And <a href="https://docs.yugabyte.com/latest/introduction/" data-href="https://docs.yugabyte.com/latest/introduction/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">YugaByteDB</a> got more attention recently when announcing that their product license is now <a href="https://twitter.com/YugaByte/status/1151142697735983105" data-href="https://twitter.com/YugaByte/status/1151142697735983105" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">100% Open Source</a>.</p><p name="1ba8" id="1ba8" class="graf graf--p graf-after--p">I like to learn new things by trying and troubleshooting rather than reading the documentation. Probably because there’s more to learn aside of the documentation path. And also because troubleshooting is fun. So, one of the great features is that the query layer is compatible with PostgreSQL. Then I’ll try to run pgBench on YugaByteDB.</p><p name="5077" id="5077" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">It is important to mention here that I’m running all nodes in a single lab VM, so performance is not representative. And I’m testing the YSQL query layer which is still in beta.</strong> The goal is to discover and learn about the distributed database challenges, rather than evaluating the product.</p><h3 name="b0d3" id="b0d3" class="graf graf--h3 graf-after--p">Install YugaByteDB</h3><p name="444f" id="444f" class="graf graf--p graf-after--h3">Nothing is easier than the installation of YugaByteDB, all documented:</p><div name="b9f5" id="b9f5" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://docs.yugabyte.com/latest/quick-start/install/" data-href="https://docs.yugabyte.com/latest/quick-start/install/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.yugabyte.com/latest/quick-start/install/"><strong class="markup--strong markup--mixtapeEmbed-strong">Install YugaByte DB | YugaByte DB Docs</strong><br><em class="markup--em markup--mixtapeEmbed-em">YugaByte DB, the high-performance distributed SQL database for global, internet-scale apps.</em>docs.yugabyte.com</a><a href="https://docs.yugabyte.com/latest/quick-start/install/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="971ca963f7c37dc68de7339ea0138a80" data-thumbnail-img-id="0*yP0FxGvJf6JBNE14" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*yP0FxGvJf6JBNE14);"></a></div><p name="cfbe" id="cfbe" class="graf graf--p graf-after--mixtapeEmbed">I install it in RHEL 7.6 (Actually OEL 7.6 as I’m running my lab in an Oracle Cloud VM). The install is just an un-tar followed by the post-install which patches the binaries so that we don’t have to set LD_LIBRARY_PATH. I set PATH to the YugaByte bin directory:</p><pre name="0821" id="0821" class="graf graf--pre graf-after--p">wget -O- <a href="https://downloads.yugabyte.com/yugabyte-1.3.0.0-linux.tar.gz" data-href="https://downloads.yugabyte.com/yugabyte-1.3.0.0-linux.tar.gz" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://downloads.yugabyte.com/yugabyte-1.3.0.0-linux.tar.gz</a> | tar -xvf - <br>export PATH=$PATH:$PWD/yugabyte-1.3.0.0/bin<br>post_install.sh</pre><p name="3c9a" id="3c9a" class="graf graf--p graf-after--pre">I create a 3 nodes cluster on this host:</p><pre name="55b2" id="55b2" class="graf graf--pre graf-after--p">yb-ctl --rf 3 create<br>yb-ctl status</pre><p name="7a33" id="7a33" class="graf graf--p graf-after--pre">Those nodes are created as 127.0.0.1 to 127.0.0.3 here. I access remotely and I tunnel the interesting ports with my ssh_config file:</p><pre name="bba1" id="bba1" class="graf graf--pre graf-after--p">Host yb<br>        HostName 130.61.59.66<br>        User opc<br>        ForwardX11 yes<br>        DynamicForward 8080<br>        #YSQL JDBC<br>        LocalForward 15433 127.0.0.1:5433<br>        LocalForward 25433 127.0.0.2:5433<br>        LocalForward 35433 127.0.0.3:5433<br>        #YCQL API<br>        LocalForward 19042 127.0.0.1:9042<br>        LocalForward 29042 127.0.0.2:9042<br>        LocalForward 39042 127.0.0.3:9042<br>        # Web UI<br>        LocalForward 17000 127.0.0.1:7000<br>        LocalForward 27000 127.0.0.2:7000<br>        LocalForward 37000 127.0.0.3:7000</pre><p name="442b" id="442b" class="graf graf--p graf-after--pre">I create a database. The “psql” equivalent here is “ysqlsh”:</p><pre name="cfd1" id="cfd1" class="graf graf--pre graf-after--p">ysqlsh<br> \timing on<br> drop database if exists franck;<br> create database franck;<br> \q</pre><figure name="2cf5" id="2cf5" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 285px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40.699999999999996%;"></div><img class="graf-image" data-image-id="1*DK0v0XiAXHyYCSD79w4u5g.png" data-width="975" data-height="397" src="https://cdn-images-1.medium.com/max/800/1*DK0v0XiAXHyYCSD79w4u5g.png"></div><figcaption class="imageCaption">ysqlsh (11.2)</figcaption></figure><h3 name="0c69" id="0c69" class="graf graf--h3 graf-after--figure">Install PgBench</h3><p name="20cc" id="20cc" class="graf graf--p graf-after--h3">As I tunneled the 5433 port I can use pgBench from my laptop:</p><pre name="c60d" id="c60d" class="graf graf--pre graf-after--p">pgbench --host localhost --port 15433 --username postgres franck</pre><p name="6a79" id="6a79" class="graf graf--p graf-after--pre">But the full postgres installation is also there in ./yugabyte-1.3.0.0/postgres</p><figure name="30b5" id="30b5" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 123px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 17.599999999999998%;"></div><img class="graf-image" data-image-id="1*5bK3u-pWVgQ_mFadsmxUww.png" data-width="1232" data-height="217" src="https://cdn-images-1.medium.com/max/800/1*5bK3u-pWVgQ_mFadsmxUww.png"></div></figure><p name="be9b" id="be9b" class="graf graf--p graf-after--figure">then, I add this in my path:</p><pre name="7c8c" id="7c8c" class="graf graf--pre graf-after--p">export PATH=$PATH:$PWD/yugabyte-1.3.0.0/bin:$PWD/yugabyte-1.3.0.0/postgres/bin</pre><h3 name="6cb1" id="6cb1" class="graf graf--h3 graf-after--pre">Initialize pgBench</h3><p name="044f" id="044f" class="graf graf--p graf-after--h3">I run the initialization:</p><pre name="5102" id="5102" class="graf graf--pre graf-after--p">pgbench --initialize --host localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="2249" id="2249" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 115px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 11.200000000000001%;"></div><img class="graf-image" data-image-id="1*9hDhnzOumljcVoHDR35YFg.png" data-width="1890" data-height="211" src="https://cdn-images-1.medium.com/max/1200/1*9hDhnzOumljcVoHDR35YFg.png"></div><figcaption class="imageCaption">ERROR: DROP multiple objects not supported yet<br>HINT: See <a href="https://github.com/YugaByte/yugabyte-db/issues/880" data-href="https://github.com/YugaByte/yugabyte-db/issues/880" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://github.com/YugaByte/yugabyte-db/issues/880</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="ebad" id="ebad" class="graf graf--p graf-after--figure">Ok, I have an error because pgBench uses the <a href="https://www.postgresql.org/docs/current/sql-droptable.html" data-href="https://www.postgresql.org/docs/current/sql-droptable.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">multi-table drop</a> statement which is not supported yet. But what’s really nice is the error message containing a link to the GitHub issue about this.</p><p name="f329" id="f329" class="graf graf--p graf-after--p">No problem, I don’t need to drop the tables and pgBench has an --init-steps option to choose the steps: <strong class="markup--strong markup--p-strong">d</strong>rop tables, <strong class="markup--strong markup--p-strong">t</strong>able creation, <strong class="markup--strong markup--p-strong">g</strong>enerate data, <strong class="markup--strong markup--p-strong">v</strong>acuum, <strong class="markup--strong markup--p-strong">p</strong>rimary key creation, <strong class="markup--strong markup--p-strong">f</strong>oreign key creation.</p><pre name="4032" id="4032" class="graf graf--pre graf-after--p">pgbench --initialize --init-steps=tgvpf -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="5772" id="5772" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 306px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 29.599999999999998%;"></div><img class="graf-image" data-image-id="1*DkIlkCubRCVp7bc47alNug.png" data-width="1340" data-height="397" src="https://cdn-images-1.medium.com/max/1200/1*DkIlkCubRCVp7bc47alNug.png"></div><figcaption class="imageCaption">ERROR: VACUUM not supported yet<br>HINT: Please report the issue on <a href="https://github.com/YugaByte/yugabyte-db/issues" data-href="https://github.com/YugaByte/yugabyte-db/issues" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://github.com/YugaByte/yugabyte-db/issues</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="55e6" id="55e6" class="graf graf--figure graf--layoutOutsetLeft graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 525px; max-height: 542px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 103.2%;"></div><img class="graf-image" data-image-id="1*yFcUlj45rRSRQy44CyHo3g.png" data-width="951" data-height="981" src="https://cdn-images-1.medium.com/max/600/1*yFcUlj45rRSRQy44CyHo3g.png"></div></figure><p name="eda9" id="eda9" class="graf graf--p graf-after--figure">There’s no FILLFACTOR and no VACUUM per-se (the storage engine has a transparent garbage collector). YugaByteDB uses the PostgreSQL <a href="https://blog.yugabyte.com/distributed-postgresql-on-a-google-spanner-architecture-query-layer/" data-href="https://blog.yugabyte.com/distributed-postgresql-on-a-google-spanner-architecture-query-layer/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">query layer</a>, but not the same <a href="https://blog.yugabyte.com/distributed-postgresql-on-a-google-spanner-architecture-storage-layer/" data-href="https://blog.yugabyte.com/distributed-postgresql-on-a-google-spanner-architecture-storage-layer/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">storage layer</a>. My tables are created and data is generated:</p><pre name="b135" id="b135" class="graf graf--pre graf-after--p">ysqlsh franck<br> \dt<br> select count(*) from pgbench_branches;<br> select count(*) from pgbench_accounts;<br> select count(*) from pgbench_tellers;<br> select count(*) from pgbench_history;</pre><p name="db77" id="db77" class="graf graf--p graf-after--pre">Let’s continue without vacuum, only the <strong class="markup--strong markup--p-strong">p</strong>rimary and <strong class="markup--strong markup--p-strong">f</strong>oreign key definition:</p><pre name="1fda" id="1fda" class="graf graf--pre graf-after--p">pgbench --initialize --init-steps=pf -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="0319" id="0319" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 109px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 10.6%;"></div><img class="graf-image" data-image-id="1*9PfyNEtA2lXAaQnj9hXkvA.png" data-width="1304" data-height="138" src="https://cdn-images-1.medium.com/max/1200/1*9PfyNEtA2lXAaQnj9hXkvA.png"></div><figcaption class="imageCaption">ERROR: This ALTER TABLE command is not yet supported.</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="ebec" id="ebec" class="graf graf--p graf-after--figure">pgBench adds the constraints with an ALTER TABLE but YugaByteDB supports only inline declaration in the CREATE TABLE. You can check the DDL from a PostgreSQL database (initialize with the ‘<strong class="markup--strong markup--p-strong">f</strong>oreign key’ step which is not the default):</p><pre name="9d14" id="9d14" class="graf graf--pre graf-after--p">pg_dump --schema-only -h localhost -p 5433 -U postgres franck</pre><p name="07ef" id="07ef" class="graf graf--p graf-after--pre">Basically, here is what is missing in my YugaByteDB database:</p><pre name="ae7c" id="ae7c" class="graf graf--pre graf-after--p">alter table pgbench_branches add primary key (bid);</pre><pre name="5212" id="5212" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_tellers add primary key (tid)&quot;,<br>  &quot;alter table pgbench_accounts add primary key (aid)&quot;</pre><pre name="7338" id="7338" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_tellers add constraint pgbench_tellers_bid_fkey foreign key (bid) references pgbench_branches&quot;,</pre><pre name="a08d" id="a08d" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_accounts add constraint pgbench_accounts_bid_fkey foreign key (bid) references pgbench_branches&quot;,</pre><pre name="5911" id="5911" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_history add constraint pgbench_history_bid_fkey foreign key (bid) references pgbench_branches&quot;,</pre><pre name="8f82" id="8f82" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_history add constraint pgbench_history_tid_fkey foreign key (tid) references pgbench_tellers&quot;,</pre><pre name="c274" id="c274" class="graf graf--pre graf-after--pre">&quot;alter table pgbench_history add constraint pgbench_history_aid_fkey foreign key (aid) references pgbench_accounts&quot;</pre><h3 name="f1f9" id="f1f9" class="graf graf--h3 graf-after--pre">Re-Create with Primary and Foreign Keys</h3><p name="764f" id="764f" class="graf graf--p graf-after--h3">Finally, here is what I want to run to get everything in a supported way:</p><pre name="a9fe" id="a9fe" class="graf graf--pre graf-after--p">ysqlsh franck</pre><pre name="3d3b" id="3d3b" class="graf graf--pre graf-after--pre"> drop table if exists pgbench_history;<br> drop table if exists pgbench_tellers;<br> drop table if exists pgbench_accounts;<br> drop table if exists pgbench_branches;</pre><pre name="70b8" id="70b8" class="graf graf--pre graf-after--pre">CREATE TABLE pgbench_branches (<br>    bid integer NOT NULL<br>   ,bbalance integer<br>   ,filler character(88)<br>   ,CONSTRAINT pgbench_branches_pkey PRIMARY KEY (bid)<br> );</pre><pre name="4523" id="4523" class="graf graf--pre graf-after--pre">CREATE TABLE pgbench_accounts (<br>    aid integer NOT NULL<br>   ,bid integer references pgbench_branches<br>   ,abalance integer<br>   ,filler character(84)<br>   ,CONSTRAINT pgbench_accounts_pkey PRIMARY KEY (aid)<br> );</pre><pre name="0b4f" id="0b4f" class="graf graf--pre graf-after--pre">CREATE TABLE pgbench_tellers (<br>    tid integer NOT NULL<br>   ,bid integer references pgbench_branches<br>   ,tbalance integer<br>   ,filler character(84)<br>   ,CONSTRAINT pgbench_tellers_pkey PRIMARY KEY (tid)<br> );</pre><pre name="c7d3" id="c7d3" class="graf graf--pre graf-after--pre">CREATE TABLE pgbench_history (<br>    tid integer references pgbench_tellers<br>   ,bid integer references pgbench_branches<br>   ,aid integer references pgbench_accounts<br>   ,delta integer<br>   ,mtime timestamp without time zone<br>   ,filler character(22)<br> );<br>\q</pre><p name="bfef" id="bfef" class="graf graf--p graf-after--pre">This creates the tables without any error. Next step is to <strong class="markup--strong markup--p-strong">g</strong>enerate data</p><h3 name="cad2" id="cad2" class="graf graf--h3 graf-after--p">Generate data</h3><figure name="cf5a" id="cf5a" class="graf graf--figure graf--layoutOutsetLeft graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 525px; max-height: 223px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 42.5%;"></div><img class="graf-image" data-image-id="1*RvRGzOHqBAc3b9jGawslsw.png" data-width="583" data-height="248" src="https://cdn-images-1.medium.com/max/600/1*RvRGzOHqBAc3b9jGawslsw.png"></div></figure><p name="246b" id="246b" class="graf graf--p graf-after--figure">Now the only “ --initialize” step I have to do is the generation of data.</p><p name="396b" id="396b" class="graf graf--p graf-after--p">Note that this step is doing the truncate with multi-table syntax and this one is already implemented.</p><p name="8b4b" id="8b4b" class="graf graf--p graf-after--p">So here is the “<strong class="markup--strong markup--p-strong">g</strong>enerate data” step:</p><pre name="9155" id="9155" class="graf graf--pre graf-after--p">pgbench --initialize --init-steps=g -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="5d59" id="5d59" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 149px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 14.399999999999999%;"></div><img class="graf-image" data-image-id="1*HaZux9kbAu8O5ZNFeCQ7Fw.png" data-width="1348" data-height="194" src="https://cdn-images-1.medium.com/max/1200/1*HaZux9kbAu8O5ZNFeCQ7Fw.png"></div><figcaption class="imageCaption">ERROR: Operation only supported in SERIALIZABLEisolation level<br>HINT: See <a href="https://github.com/YugaByte/yugabyte-db/issues/1199" data-href="https://github.com/YugaByte/yugabyte-db/issues/1199" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://github.com/YugaByte/yugabyte-db/issues/1199</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="7896" id="7896" class="graf graf--p graf-after--figure">PostgreSQL runs by default in “read committed” isolation level. As the GitHub issue mentions, YugaByteDB support for Foreign Keys requires “Serializable”. The reason is that the storage engine (DocDB) has no explicit row locking yet to lock the referenced row. But with referential integrity, inserting in a child table must lock the parent row in share mode (like a SELECT FOR KEY SHARE) to ensure that it is not currently being deleted (or the referenced columns updated). Then the no-lock solution is to run in a true Serializable isolation level.</p><p name="f343" id="f343" class="graf graf--p graf-after--p">About the support of Foreign Keys, read Bryn Llewellyn blog post:</p><div name="4609" id="4609" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blog.yugabyte.com/relational-data-modeling-with-foreign-keys-in-a-distributed-sql-database/" data-href="https://blog.yugabyte.com/relational-data-modeling-with-foreign-keys-in-a-distributed-sql-database/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.yugabyte.com/relational-data-modeling-with-foreign-keys-in-a-distributed-sql-database/"><strong class="markup--strong markup--mixtapeEmbed-strong">Relational Data Modeling with Foreign Keys in a Distributed SQL Database - The Distributed SQL Blog</strong><br><em class="markup--em markup--mixtapeEmbed-em">Primary and foreign key constraints are as essential to a relational database as are tables and columns-without these…</em>blog.yugabyte.com</a><a href="https://blog.yugabyte.com/relational-data-modeling-with-foreign-keys-in-a-distributed-sql-database/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="63f8d082b3b350bdbe5063b589c1f6ce" data-thumbnail-img-id="0*k0jo2cizk-wAVggh" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*k0jo2cizk-wAVggh);"></a></div><p name="dd32" id="dd32" class="graf graf--p graf-after--mixtapeEmbed">Note that I said “true” Serializable isolation level because I’m used to Oracle Database where this term is used for “Snapshot Isolation”- more about this:</p><div name="0ea1" id="0ea1" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blog.dbi-services.com/oracle-serializable-is-not-serializable/" data-href="https://blog.dbi-services.com/oracle-serializable-is-not-serializable/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.dbi-services.com/oracle-serializable-is-not-serializable/"><strong class="markup--strong markup--mixtapeEmbed-strong">Oracle serializable is not serializable - Blog dbi services</strong><br><em class="markup--em markup--mixtapeEmbed-em">By Franck Pachot . Did you know that when you set isolation level to SERIALIZABLE, it is not serializable but SNAPSHOT…</em>blog.dbi-services.com</a><a href="https://blog.dbi-services.com/oracle-serializable-is-not-serializable/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c0a24482f60fb05d13dac32cf1a6ebcb" data-thumbnail-img-id="0*JnLgp42heONqHJZ3" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*JnLgp42heONqHJZ3);"></a></div><h4 name="a1ae" id="a1ae" class="graf graf--h4 graf-after--mixtapeEmbed">Serializable transaction isolation</h4><p name="1f27" id="1f27" class="graf graf--p graf-after--h4">So, the current transaction isolation level is “Read Committed” where repeatable reads, which is required by foreign keys, needs SELECT FOR KEY SHARE:</p><pre name="1262" id="1262" class="graf graf--pre graf-after--p">ysqlsh franck<br> select current_setting(&#39;transaction_isolation&#39;);<br> \q</pre><figure name="39a6" id="39a6" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 132px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 18.8%;"></div><img class="graf-image" data-image-id="1*1iOmbDsucHvCv5VRpDj_lA.png" data-width="1390" data-height="262" src="https://cdn-images-1.medium.com/max/800/1*1iOmbDsucHvCv5VRpDj_lA.png"></div></figure><p name="3763" id="3763" class="graf graf--p graf-after--figure">Then, in order to be able to insert in a table that has some foreign keys, I set the default isolation level to Serializable for my database, and re-connect to check it:</p><pre name="d151" id="d151" class="graf graf--pre graf-after--p">ysqlsh franck<br> alter database franck set default_transaction_isolation=serializable;<br> \c franck postgres localhost 5433<br> select current_setting(&#39;transaction_isolation&#39;);<br> \q</pre><figure name="6f61" id="6f61" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 186px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 26.5%;"></div><img class="graf-image" data-image-id="1*R-T-ZWzVHm6sC_7ULDGXLQ.png" data-width="1360" data-height="361" src="https://cdn-images-1.medium.com/max/800/1*R-T-ZWzVHm6sC_7ULDGXLQ.png"></div></figure><h4 name="4a03" id="4a03" class="graf graf--h4 graf-after--figure">Update 27-JUL-2019</h4><p name="7d95" id="7d95" class="graf graf--p graf-after--h4">If you don’t want to change the default, you can also set:</p><pre name="3d3d" id="3d3d" class="graf graf--pre graf-after--p">PGOPTIONS=&#39;-c default_transaction_isolation=serializable&#39;</pre><h4 name="5fa1" id="5fa1" class="graf graf--h4 graf-after--pre">Generate data with serializable transactions</h4><p name="2c3f" id="2c3f" class="graf graf--p graf-after--h4">Ok, let’s try to generate data now:</p><pre name="4282" id="4282" class="graf graf--pre graf-after--p">pgbench --initialize --init-steps=g -h localhost -p 5433 -U postgres franck</pre><p name="34aa" id="34aa" class="graf graf--p graf-after--pre">That is taking a long time so I attach the debugger on it:</p><pre name="37cd" id="37cd" class="graf graf--pre graf-after--p">gdb $(pgrep pgbench)</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="2d87" id="2d87" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 257px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 24.9%;"></div><img class="graf-image" data-image-id="1*NptyM1kZfqJlkcZuG6KaFg.png" data-width="2381" data-height="594" src="https://cdn-images-1.medium.com/max/1200/1*NptyM1kZfqJlkcZuG6KaFg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="0894" id="0894" class="graf graf--figure graf--layoutOutsetLeft graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 525px; max-height: 200px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 38.1%;"></div><img class="graf-image" data-image-id="1*oXm0WSKcoZcsjDpiK_O4gQ.png" data-width="981" data-height="374" src="https://cdn-images-1.medium.com/max/600/1*oXm0WSKcoZcsjDpiK_O4gQ.png"></div><figcaption class="imageCaption"><a href="https://github.com/YugaByte/yugabyte-db/blob/master/src/postgres/src/bin/pgbench/pgbench.c#L3704" data-href="https://github.com/YugaByte/yugabyte-db/blob/master/src/postgres/src/bin/pgbench/pgbench.c#L3704" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://github.com/YugaByte/yugabyte-db/blob/master/src/postgres/src/bin/pgbench/pgbench.c#L3704</a></figcaption></figure><p name="7c99" id="7c99" class="graf graf--p graf-after--figure"><a href="https://github.com/YugaByte/yugabyte-db/blob/master/src/postgres/src/bin/pgbench/pgbench.c#L3704" data-href="https://github.com/YugaByte/yugabyte-db/blob/master/src/postgres/src/bin/pgbench/pgbench.c#L3704" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pgbench.c:3704</a> is the call to PQendcopy() which is waiting for the asynchronous COPY completion, COPY is used by pgBench for the large table “pg_accounts”. On YugaByteDB side, it seems that only one Tablet Server is doing the work, 100% in CPU:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="689d" id="689d" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 110px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 10.6%;"></div><img class="graf-image" data-image-id="1*BMPsAR8l0xjSdEuOsq-UMg.png" data-width="2707" data-height="288" src="https://cdn-images-1.medium.com/max/1200/1*BMPsAR8l0xjSdEuOsq-UMg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="3d56" id="3d56" class="graf graf--p graf-after--figure">The Tablet Server is running code from librocksdb.so (the YugaByteDB storage engine, DocDB, is based on RocksDB):</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="7639" id="7639" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 270px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 26.200000000000003%;"></div><img class="graf-image" data-image-id="1*pH6chs-o4nRfEeP0dNqk6A.png" data-width="2196" data-height="575" src="https://cdn-images-1.medium.com/max/1200/1*pH6chs-o4nRfEeP0dNqk6A.png"></div><figcaption class="imageCaption">perf top</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="8fa0" id="8fa0" class="graf graf--figure graf--iframe graf--layoutOutsetLeft graf-after--figure"><script src="https://gist.github.com/FranckPachot/b676683025ea6bdfdcea448965fa5a2a#file-pgbench-yugabytedb-init-fk-svg.js"></script></figure><p name="1c8f" id="1c8f" class="graf graf--p graf-after--figure">While I was waiting I generated a Brendan Gregg flamegraph on the busy Tablet Server, but there’s no visible bottleneck.</p><pre name="3490" id="3490" class="graf graf--pre graf-after--p">sudo perf record -e cpu-cycles -o /tmp/perf.out -F 99 -g<br>^C<br>git clone <a href="https://github.com/brendangregg/FlameGraph.git" data-href="https://github.com/brendangregg/FlameGraph.git" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://github.com/brendangregg/FlameGraph.git</a><br>sudo perf script -i /tmp/perf.out | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl /dev/stdin &gt; /tmp/perf.folded.svg</pre><p name="7e4d" id="7e4d" class="graf graf--p graf-after--pre">This goes beyond the goal of this post and, anyway, looking at performance is probably not relevant in this version. <strong class="markup--strong markup--p-strong">[21-JUL-2019: the support for COPY has just been added since this test - more info </strong><a href="https://twitter.com/JaydenNavarro/status/1153048251328651264?s=20" data-href="https://twitter.com/JaydenNavarro/status/1153048251328651264?s=20" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">here</strong></a><strong class="markup--strong markup--p-strong">]</strong></p><p name="449d" id="449d" class="graf graf--p graf-after--p">Finally, the initialization of 100000 tuples finished after one hour:</p><figure name="77a4" id="77a4" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 131px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 18.7%;"></div><img class="graf-image" data-image-id="1*9Ui5Mu7cFK2RKpjrl7tqYQ.png" data-width="1425" data-height="267" src="https://cdn-images-1.medium.com/max/800/1*9Ui5Mu7cFK2RKpjrl7tqYQ.png"></div><figcaption class="imageCaption">time pgbench --initialize --init-steps=g -h localhost -p 5433 -U postgres franck</figcaption></figure><p name="0609" id="0609" class="graf graf--p graf-after--figure">So, finally, I have my pgBench schema loaded, with all referential integrity and data.</p><h3 name="9ce8" id="9ce8" class="graf graf--h3 graf-after--p">pgBench simple-update in single-session</h3><p name="60fc" id="60fc" class="graf graf--p graf-after--h3">I’m running the “simple-update” which basically updates the “abalance” for a row in “pgbench_accounts”, and inserts into “pgbench_history”.</p><pre name="61f0" id="61f0" class="graf graf--pre graf-after--p">pgbench --no-vacuum --builtin=simple-update --protocol=prepared --time 30 -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="8fee" id="8fee" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 182px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 17.7%;"></div><img class="graf-image" data-image-id="1*I4Ypc0PUFUCLEB-9NK_mSA.png" data-width="1868" data-height="330" src="https://cdn-images-1.medium.com/max/1200/1*I4Ypc0PUFUCLEB-9NK_mSA.png"></div><figcaption class="imageCaption">pgbench --no-vacuum --builtin=simple-update --protocol=prepared --time 30 -h localhost -p 5433 -U postgres franck</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="447f" id="447f" class="graf graf--p graf-after--figure">At least I know that this basic OLTP application can run without any change on YugaByteDB and that’s a very good point for application transparency. I’ll explain later why I start here the “simple update” workload rather than the default. The Transaction Per Second rate is not amazing (it is 150x higher on a plain PostgreSQL on the same platform), but this is not what I am testing here.</p><h3 name="7f0b" id="7f0b" class="graf graf--h3 graf-after--p">pgBench simple-update in multi-sessions</h3><p name="aa5f" id="aa5f" class="graf graf--p graf-after--h3">Obviously, a distributed database should be scalable when multiple users are working in parallel. For this I run pgBnech with 10 clients from 10 threads:</p><pre name="a55a" id="a55a" class="graf graf--pre graf-after--p">pgbench --no-vacuum --protocol=prepared --builtin=simple-update --time 30 --jobs=10 --client=10 -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="51d2" id="51d2" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 156px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 15.2%;"></div><img class="graf-image" data-image-id="1*r6V2aIuWDHpFGj2iAnwSJw.png" data-width="2138" data-height="324" src="https://cdn-images-1.medium.com/max/1200/1*r6V2aIuWDHpFGj2iAnwSJw.png"></div><figcaption class="imageCaption">pgbench — no-vacuum — protocol=prepared — builtin=simple-update — time 30 — jobs=10 — client=10 -h localhost -p 5433 -U postgres franck</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="bdf4" id="bdf4" class="graf graf--p graf-after--figure">Good. I said that we should not look at the elapsed time, but the comparison with the previous run shows the scalability as 10 sessions can run about 10x more transactions per second. I run the 3 YugaByteDB nodes on a 24 core virtual machine here. The servers are multi-threaded:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="87dd" id="87dd" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 256px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 24.8%;"></div><img class="graf-image" data-image-id="1*iPxJf_jexYh46jJANlHtVQ.png" data-width="2331" data-height="579" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*iPxJf_jexYh46jJANlHtVQ.png"></div><figcaption class="imageCaption">nTH: number of threads (LWP), P: last used CPU (SMP)</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="71e4" id="71e4" class="graf graf--h3 graf-after--figure">pgBench TCPB-like in multi-sessions</h3><figure name="8483" id="8483" class="graf graf--figure graf--layoutOutsetLeft graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 525px; max-height: 423px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 80.60000000000001%;"></div><img class="graf-image" data-image-id="1*RFkpkfNHq7Lw-NqrE4r-VA.png" data-width="749" data-height="604" src="https://cdn-images-1.medium.com/max/600/1*RFkpkfNHq7Lw-NqrE4r-VA.png"></div><figcaption class="imageCaption"><a href="https://www.slideshare.net/Clustrix/demystifying-benchmarks-how-to-use-them-to-better-evaluate-databases" data-href="https://www.slideshare.net/Clustrix/demystifying-benchmarks-how-to-use-them-to-better-evaluate-databases" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Demystifying Benchmarks: How to Use Them To Better Evaluate Databases</a></figcaption></figure><p name="e383" id="e383" class="graf graf--p graf-after--figure">Actually, the first test I did was the default pgBench workload, which is the “<a href="http://www.tpc.org/tpcb/" data-href="http://www.tpc.org/tpcb/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">TPC-B</a> (sort of)”. In addition to the “simple update”, each transaction updates, in addition to “pg_account”, the balance “pgbench_tellers” and “pgbench_branches”.</p><p name="0f31" id="0f31" class="graf graf--p graf-after--p">This is more tricky because multiple clients will have to concurrently update the same records. And there’s a high probability of contention given the cardinalities. There, pessimistic locking would be better than optimistic. I’m still with my Foreign Keys here and Serializable isolation level (which is optimistic locking).</p><pre name="7ed6" id="7ed6" class="graf graf--pre graf-after--p">pgbench --no-vacuum --protocol=prepared --builtin=simple-update --time 30 --jobs=10 --client=10 -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="a1ba" id="a1ba" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 349px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.800000000000004%;"></div><img class="graf-image" data-image-id="1*kHIvHPlJ8513K-isvpbbzg.png" data-width="2384" data-height="806" src="https://cdn-images-1.medium.com/max/1200/1*kHIvHPlJ8513K-isvpbbzg.png"></div><figcaption class="imageCaption"><strong class="markup--strong markup--figure-strong">ERROR</strong>: <strong class="markup--strong markup--figure-strong">could not serialize access due to concurrent update</strong></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="bbbe" id="bbbe" class="graf graf--p graf-after--figure">Quickly I can see that 9 out of the 10 clients failed with “Conflicts with higher priority transaction”. This is the equivalent to the PostgreSQL “ERROR: could not serialize access due to concurrent update”. With optimistic locking, the application must be ready to re-try a failed transaction, but pgBench has no option for that. This is not special to YugaByteDB: you will get the same in PostgreSQL when running pgBench default workload in a Serializable transaction isolation level.</p><p name="7aff" id="7aff" class="graf graf--p graf-after--p">Anyway, given the high probability of collision here, the solution is pessimistic locking.</p><h3 name="cae3" id="cae3" class="graf graf--h3 graf-after--p">Read Committed transaction isolation</h3><p name="d44e" id="d44e" class="graf graf--p graf-after--h3">If I set back the isolation level to “Read Committed” the UPDATE will use pessimistic locking, and then I expect the transactions to be serialized, waiting to see committed changes rather than failing when encountering a concurrent change.</p><pre name="8f27" id="8f27" class="graf graf--pre graf-after--p">ysqlsh franck<br> alter database franck set default_transaction_isolation=&#39;read committed&#39;;<br> \q</pre><p name="c7c3" id="c7c3" class="graf graf--p graf-after--pre">But then, I cannot declare the foreign keys or I’ll get “ ERROR: Operation only supported in SERIALIZABLE isolation level” until the <a href="https://github.com/YugaByte/yugabyte-db/issues/1199" data-href="https://github.com/YugaByte/yugabyte-db/issues/1199" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">issue #1199</a> is fixed.</p><h4 name="ad4b" id="ad4b" class="graf graf--h4 graf-after--p">Without referential integrity constraints</h4><p name="7527" id="7527" class="graf graf--p graf-after--h4">I re-create the tables with the REFERENCES clause commented out:</p><pre name="25b3" id="25b3" class="graf graf--pre graf-after--p">ysqlsh franck<br> drop table if exists pgbench_history;<br> drop table if exists pgbench_tellers;<br> drop table if exists pgbench_accounts;<br> drop table if exists pgbench_branches;<br> CREATE TABLE pgbench_branches (<br>    bid integer NOT NULL<br>   ,bbalance integer<br>   ,filler character(88)<br>   ,CONSTRAINT pgbench_branches_pkey PRIMARY KEY (bid)<br> );<br> CREATE TABLE pgbench_accounts (<br>    aid integer NOT NULL<br>   ,bid integer --references pgbench_branches<br>   ,abalance integer<br>   ,filler character(84)<br>   ,CONSTRAINT pgbench_accounts_pkey PRIMARY KEY (aid)<br> );<br> CREATE TABLE pgbench_tellers (<br>    tid integer NOT NULL<br>   ,bid integer --references pgbench_branches<br>   ,tbalance integer<br>   ,filler character(84)<br>   ,CONSTRAINT pgbench_tellers_pkey PRIMARY KEY (tid)<br> );<br> CREATE TABLE pgbench_history (<br>    tid integer --references pgbench_tellers<br>   ,bid integer --references pgbench_branches<br>   ,aid integer --references pgbench_accounts<br>   ,delta integer<br>   ,mtime timestamp without time zone<br>   ,filler character(22)<br> );<br> \q</pre><p name="f613" id="f613" class="graf graf--p graf-after--pre">And run the initialize again, which is much faster (2 minutes instead of 1 hour):</p><figure name="73ad" id="73ad" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 98px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 14.000000000000002%;"></div><img class="graf-image" data-image-id="1*-ju3VdDoqxVj9nYip-FSjw.png" data-width="1578" data-height="221" src="https://cdn-images-1.medium.com/max/800/1*-ju3VdDoqxVj9nYip-FSjw.png"></div><figcaption class="imageCaption">time pgbench --initialize --init-steps=g -h localhost -p 5433 -U postgres franck</figcaption></figure><p name="da4c" id="da4c" class="graf graf--p graf-after--figure">Then, ready to run my 10 clients TPC-B workload:</p><pre name="fc0c" id="fc0c" class="graf graf--pre graf-after--p">pgbench --no-vacuum --protocol=prepared --builtin=simple-update --time 30 --jobs=10 --client=10 -h localhost -p 5433 -U postgres franck</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="4bae" id="4bae" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 332px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.2%;"></div><img class="graf-image" data-image-id="1*26q4LMryShhBgcLRUS7cxw.png" data-width="2171" data-height="698" src="https://cdn-images-1.medium.com/max/1200/1*26q4LMryShhBgcLRUS7cxw.png"></div><figcaption class="imageCaption">Operation failed. Try again.: Conflicts with higher priority transaction <br>ERROR: Operation failed. Try again.: Conflicts with committed transaction<br>ERROR: Error during commit: Operation expired: Transaction expired</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e361" id="e361" class="graf graf--p graf-after--figure">This is much better. Among the 23574 transactions, I got only 3 errors and 7 clients were still running concurrently. I’ve also run it with only one client where I had TPS=144 and here with 7 clients remaining we reach TPS=785.</p><p name="b544" id="b544" class="graf graf--p graf-after--p">Of course, I would expect no “Try again” error when in Read Committed isolation level. Here I have the 3 out of the 5 transactional errors we can get from libpq calls (according to yugabyte <a href="https://github.com/YugaByte/yugabyte-db/blob/master/src/yb/yql/pgwrapper/pg_libpq-test.cc" data-href="https://github.com/YugaByte/yugabyte-db/blob/master/src/yb/yql/pgwrapper/pg_libpq-test.cc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pg_libpq-test.cc</a>):</p><ul class="postList"><li name="4b26" id="4b26" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Transaction expired</strong></li><li name="d224" id="d224" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Conflicts with committed transaction</strong></li><li name="62b3" id="62b3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Conflicts with higher priority transaction</strong></li><li name="612d" id="612d" class="graf graf--li graf-after--li">Restart read required</li><li name="a170" id="a170" class="graf graf--li graf-after--li">Value write after transaction start</li></ul><p name="9764" id="9764" class="graf graf--p graf-after--li">But that’s probably for another post. The important outcomes from my very first test of YugaByteDB are:</p><ul class="postList"><li name="1550" id="1550" class="graf graf--li graf-after--p">It is very easy to install and test, so… try it (and you will get a link to get a nice T-Shirt shipped to your home)</li><li name="9b4a" id="9b4a" class="graf graf--li graf-after--li">I was able to run pgBench, a simple application written for PostgreSQL, without any change for YugaByteDB</li><li name="eb17" id="eb17" class="graf graf--li graf-after--li">Not all DDL is supported yet, but easy to workaround and follow the Git issue.</li><li name="51cf" id="51cf" class="graf graf--li graf-after--li">Foreign Keys are supported, which is a challenge for a distributed database.</li><li name="d6df" id="d6df" class="graf graf--li graf-after--li graf--trailing">Transaction concurrency is managed and the issues that will be fixed in later releases are clearly documented as Git issues</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/3a15450dfa42"><time class="dt-published" datetime="2019-07-21T18:25:32.264Z">July 21, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/running-pgbench-on-yugabytedb-1-3-3a15450dfa42" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>