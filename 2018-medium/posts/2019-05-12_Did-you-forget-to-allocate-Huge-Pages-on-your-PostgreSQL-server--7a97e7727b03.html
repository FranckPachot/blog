<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Did you forget to allocate Huge Pages on your PostgreSQL server?</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Did you forget to allocate Huge Pages on your PostgreSQL server?</h1>
</header>
<section data-field="subtitle" class="p-summary">
This short post is for those who answered ‘keep the default’ in the following. Because the default (which is no huge page allocated) is…
</section>
<section data-field="body" class="e-content">
<section name="567b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d7c3" id="d7c3" class="graf graf--h3 graf--leading graf--title">Did you forget to allocate Huge Pages on your PostgreSQL server?</h3><p name="6e7a" id="6e7a" class="graf graf--p graf-after--h3">This short post is for those who answered ‘keep the default’ in the following. Because the default (which is no huge page allocated) is not good for a database.</p><figure name="0b7c" id="0b7c" class="graf graf--figure graf--iframe graf-after--p"><blockquote class="twitter-tweet"><a href="https://twitter.com/FranckPachot/status/1127330669728808965"></a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></figure><p name="5308" id="5308" class="graf graf--p graf-after--figure">When you install a Linux server, by default, there are no Huge Pages defined until you set <strong class="markup--strong markup--p-strong">vm.nr_hugepages</strong> in /etc/sysctl.conf and reboot or ‘<strong class="markup--strong markup--p-strong">sysctl -p</strong>’.</p><p name="b776" id="b776" class="graf graf--p graf-after--p">When you install PostgreSQL, by default, <strong class="markup--strong markup--p-strong">huge_pages=try</strong> which means that the postgres server will start with no error nor warning when huge pages are not available. This is mostly the equivalent of ‘LARGE_PAGES=TRUE’ in Oracle, except that Oracle will try to allocate as much as possible in Huge Pages.</p><p name="6c26" id="6c26" class="graf graf--p graf-after--p">This setting can be considered safer in case of unplanned reboot: prefer starting in degraded mode rather than not starting at all. But the risk is that you do not realize when the shared buffers are allocated in small pages.</p><h3 name="db5f" id="db5f" class="graf graf--h3 graf-after--p">Where?</h3><p name="8933" id="8933" class="graf graf--p graf-after--h3">First, how to know if the shared buffers were allocated in small or large pages? They are shared, and then show in pmap with ‘s’ mode. Here is my pmap output when allocated as Huge Pages:</p><pre name="c738" id="c738" class="graf graf--pre graf-after--p">$ pmap $(pgrep postgres) |  grep -E -- &quot;-s- .*deleted&quot; | sort -u<br>00007fa05d600000 548864K <strong class="markup--strong markup--pre-strong">rw-s-</strong> anon_<strong class="markup--strong markup--pre-strong">hugepage</strong> (deleted)</pre><p name="cc02" id="cc02" class="graf graf--p graf-after--pre">Here is the same when allocated as small pages:</p><pre name="1f71" id="1f71" class="graf graf--pre graf-after--p">$ pmap $(pgrep postgres) |  grep -E -- &quot;-s- .*deleted&quot; | sort -u<br>00007f129b289000 547856K <strong class="markup--strong markup--pre-strong">rw-s-</strong> zero (deleted)</pre><p name="74c2" id="74c2" class="graf graf--p graf-after--pre">As far as I know, there’s no partially allocated shared buffer: if there are not enough huge pages for the total, then none are used.</p><h3 name="234a" id="234a" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">How?</strong></h3><p name="86e4" id="86e4" class="graf graf--p graf-after--h3">In order to set it, that’s easy. You set the number of 2MB pages in /etc/sysctl.conf and allocate with ‘sysctl -p’. Here is how I check the size of the memory area, from <strong class="markup--strong markup--p-strong">/proc/meminfo</strong> but formatted for humans.</p><div name="c100" id="c100" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@FranckPachot/proc-meminfo-formatted-for-humans-350c6bebc380" data-href="https://medium.com/@FranckPachot/proc-meminfo-formatted-for-humans-350c6bebc380" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@FranckPachot/proc-meminfo-formatted-for-humans-350c6bebc380"><strong class="markup--strong markup--mixtapeEmbed-strong">/proc/meminfo formatted for humans</strong><br><em class="markup--em markup--mixtapeEmbed-em">Here is a small awk script I use to format memory information on Linux:</em>medium.com</a><a href="https://medium.com/@FranckPachot/proc-meminfo-formatted-for-humans-350c6bebc380" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="31a130389ee95ea23580434c5b905356" data-thumbnail-img-id="1*RCYyPaMXPbb1-0VAoF1VTA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*RCYyPaMXPbb1-0VAoF1VTA.png);"></a></div><p name="ea57" id="ea57" class="graf graf--p graf-after--mixtapeEmbed">How much? That’s simple: Enough and not too much.</p><p name="9dc8" id="9dc8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Enough</strong> means that all shared buffers should fit. Just take the sum of all shared_buffers for all instances in the server. If you have other programs using shared memory and allocating it large pages, they count as well. And don&#39;t forget to update when you add a new instance or increase the memory for an existing one.</p><p name="87fd" id="87fd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Not too much</strong> because the processes also need to allocate their memory as small pages and what is reserved for huge pages cannot be allocated in small pages. If you do not leave enough small pages, you will have many problems and may even not be able to boot. Like this:</p><div name="42a9" id="42a9" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blog.dbi-services.com/kernel-panic-not-syncing-out-of-memory-and-no-killable-processes/" data-href="https://blog.dbi-services.com/kernel-panic-not-syncing-out-of-memory-and-no-killable-processes/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.dbi-services.com/kernel-panic-not-syncing-out-of-memory-and-no-killable-processes/"><strong class="markup--strong markup--mixtapeEmbed-strong">Kernel panic - not syncing: Out of memory and no killable processes - Blog dbi services</strong><br><em class="markup--em markup--mixtapeEmbed-em">By Franck Pachot . This is a quick post to give a solution (maybe not the best one as this was just quick…</em>blog.dbi-services.com</a><a href="https://blog.dbi-services.com/kernel-panic-not-syncing-out-of-memory-and-no-killable-processes/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7de6d9054409ecaa6b58870b5d266150" data-thumbnail-img-id="0*2VJmsZOOONa0T_C2" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*2VJmsZOOONa0T_C2);"></a></div><p name="7167" id="7167" class="graf graf--p graf-after--mixtapeEmbed">In addition to that, PostgreSQL does not support direct IO and needs some free memory for the filesystem cache, which are small pages. The <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html" data-href="https://www.postgresql.org/docs/current/runtime-config-resource.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">documentation</a> still mentions that postgres shared buffers should leave the same amount of RAM for filesystem cache (which means double buffering).</p><p name="2f6d" id="2f6d" class="graf graf--p graf-after--p">Be careful, when looking at /proc/meminfo the Huge Pages allocated by postgreSQL are free until they are used. So do not rely on <strong class="markup--strong markup--p-strong">HugePages_Free </strong>do your maths from the sum of <strong class="markup--strong markup--p-strong">shared_buffers</strong>. Use pmap to see that they are used just after starting the instance. There may be some other kernel settings to set (permissions, memlock) if allocation didn’t occur.</p><h3 name="6858" id="6858" class="graf graf--h3 graf-after--p">Why?</h3><p name="6bac" id="6bac" class="graf graf--p graf-after--h3">Do not fear it. Once you have set those areas, and checked them, they are fixed. Then no surprise if you take care. And it can make a big difference in the performance and memory footprint. The shared buffers have the following properties:</p><ul class="postList"><li name="1c47" id="1c47" class="graf graf--li graf-after--p">they are <strong class="markup--strong markup--li-strong">big</strong>, and allocating 1GB, 10GB or 100GB in 4k pages is not reasonable. Huge Pages are 2MB.</li><li name="44b0" id="44b0" class="graf graf--li graf-after--li">they are <strong class="markup--strong markup--li-strong">shared</strong>, and mapping so many small pages from many processes is not efficient. Takes lot of memory just to map them, increases the chance of TLB misses,…</li></ul><p name="6988" id="6988" class="graf graf--p graf-after--li">I’ll use Kevin Closson <strong class="markup--strong markup--p-strong">pgio</strong> (<a href="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/" data-href="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://kevinclosson.net</a>) to show how to test.</p><div name="45cb" id="45cb" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/" data-href="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/"><strong class="markup--strong markup--mixtapeEmbed-strong">Sneak Preview of pgio (The SLOB Method for PostgreSQL) Part IV: How To Reduce The Amount of Memory…</strong><br><em class="markup--em markup--mixtapeEmbed-em">I hope these sneak peeks are of interest... PostgreSQL and Buffered I/O PostgreSQL uses buffered I/O. If you want to…</em>kevinclosson.net</a><a href="https://kevinclosson.net/2018/05/23/sneak-preview-of-pgio-the-slob-method-for-postgresql-part-iv-how-to-reduce-the-amount-of-memory-in-the-linux-page-cache-for-testing-purposes/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f94de6d2c614b24e48e164562ff268af" data-thumbnail-img-id="0*dQ_DixSBa2iSouGa" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*dQ_DixSBa2iSouGa);"></a></div><p name="f97b" id="f97b" class="graf graf--p graf-after--mixtapeEmbed">Here’s my pgio.conf:</p><pre name="23f5" id="23f5" class="graf graf--pre graf-after--p">$ grep -vE &quot;^[[:blank:]]*#|^$&quot; <strong class="markup--strong markup--pre-strong">pgio.conf</strong><br>UPDATE_PCT=0<br>RUN_TIME=60<br>NUM_SCHEMAS=2<br>NUM_THREADS=2<br>WORK_UNIT=255<br>UPDATE_WORK_UNIT=8<br>SCALE=100M<br>DBNAME=pgio<br>CONNECT_STRING=pgio<br>CREATE_BASE_TABLE=TRUE</pre><pre name="ccdd" id="ccdd" class="graf graf--pre graf-after--pre">$ sh ./<strong class="markup--strong markup--pre-strong">setup.sh</strong></pre><pre name="43af" id="43af" class="graf graf--pre graf-after--pre">Job info:      Loading 100M scale into 2 schemas as per pgio.conf-&gt;NUM_SCHEMAS.<br>Batching info: Loading 2 schemas per batch as per pgio.conf-&gt;NUM_THREADS.<br>Base table loading time: 0 seconds.</pre><pre name="d90e" id="d90e" class="graf graf--pre graf-after--pre">Waiting for batch. Global schema count: 2. Elapsed: 0 seconds.<br>Waiting for batch. Global schema count: 2. Elapsed: 1 seconds.</pre><pre name="ce97" id="ce97" class="graf graf--pre graf-after--pre">Group data loading phase complete.         Elapsed: 1 seconds.</pre><p name="8dd2" id="8dd2" class="graf graf--p graf-after--pre">I have set up two 100M schemas. My shared_buffers is 500MB so all reads are cache hits:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="6bad" id="6bad" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 259px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 25.1%;"></div><img class="graf-image" data-image-id="1*5DO9LIwD6LSKBSgJCWgKBA.png" data-width="1763" data-height="442" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*5DO9LIwD6LSKBSgJCWgKBA.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="9636" id="9636" class="graf graf--p graf-after--figure">2.7 million LIOPS (Logical Reads Per Second) here. The advantage of pgio benchmark is that I focus exactly on what I want to measure: reading pages from the shared buffer. There’s minimal physical I/O here (should be zero but there was no warm up here and the test is too short), and minimal processing on the page (and this is why I use pgio and not pgbench here).</p><p name="2d67" id="2d67" class="graf graf--p graf-after--p">I have disabled Huge Pages for this test.</p><pre name="0c87" id="0c87" class="graf graf--pre graf-after--p">$ grep -E &quot;(shared_buffers|huge_pages).*=&quot; $PGDATA/postgresql.conf<br>shared_buffers=500MB<br>#shared_buffers = 128MB                 # min 128kB<br>#huge_pages = try                       # on, off, or try<br>huge_pages=off</pre><p name="6820" id="6820" class="graf graf--p graf-after--pre">Now enabling them. I keep the ‘try’ default and check that they are used. I could have set huge_pages to true to be sure.</p><pre name="a7f3" id="a7f3" class="graf graf--pre graf-after--p">$ sed -ie &#39;/^huge_pages/d&#39; $PGDATA/postgresql.conf<br>$ grep huge_pages $PGDATA/postgresql.conf<br>#huge_pages = try                       # on, off, or try</pre><pre name="a2d0" id="a2d0" class="graf graf--pre graf-after--pre">$ pg_ctl -l $PGDATA/logfile restart<br>waiting for server to shut down.... done<br>server stopped<br>waiting for server to start.... done<br>server started</pre><pre name="10ce" id="10ce" class="graf graf--pre graf-after--pre">$ pmap $(head -1 $PGDATA/postmaster.pid) | sort -hk2 | tail -4 | grep -E &quot;^|-s-&quot;<br>00007fb824d4e000  20292K r-x-- libicudata.so.50.1.2<br>00007fb81cc3f000 103592K r---- locale-archive<br>00007fb7fb200000 548864K rw-s- anon_hugepage (deleted)<br> total           800476K</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="3782" id="3782" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 325px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 31.5%;"></div><img class="graf-image" data-image-id="1*zaSNNrmALFC6MT2iH9S2bg.png" data-width="1763" data-height="555" src="https://cdn-images-1.medium.com/max/1200/1*zaSNNrmALFC6MT2iH9S2bg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e125" id="e125" class="graf graf--p graf-after--figure">Then I run the same test:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="c273" id="c273" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 245px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 23.7%;"></div><img class="graf-image" data-image-id="1*Pu9WivZqI6DM7QT-AkE1JA.png" data-width="1763" data-height="418" src="https://cdn-images-1.medium.com/max/1200/1*Pu9WivZqI6DM7QT-AkE1JA.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="b3c4" id="b3c4" class="graf graf--p graf-after--figure">Here, even with a small shared memory (500MB) and only 4 threads, the difference is visible: the cache hits performance on the small pages is only 2719719/3016865=90% of what is achieved with large pages.</p><p name="269a" id="269a" class="graf graf--p graf-after--p">Those screenshots are from a very small demo to demonstrate how to do it. If you need real numbers, run this on a longer run, like RUN_TIME=600. And on your platform, because of the overhead of large shared memory allocated in small pages depends on your CPU, your OS (with the patches to mitigate the CPU security vulnerabilities), your hypervisor,…</p><p name="a01d" id="a01d" class="graf graf--p graf-after--p">One thing is certain: <strong class="markup--strong markup--p-strong">any database shared buffer cache should be allocated in pages larger than the default.</strong> Small (4k) pages are not there for large allocations of shared areas above GigaBytes. And the second advantage is that they will never be written to swap: you allocate this memory to reduce disk I/O, and consequently, you don’t want it to be written to disk.</p><p name="7a9b" id="7a9b" class="graf graf--p graf-after--p">There’s a very nice presentation on this topic by <a href="https://twitter.com/laudares" data-href="https://twitter.com/laudares" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Fernando Laudares Camargos</a>:</p><div name="927b" id="927b" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://fosdem.org/2019/schedule/event/hugepages_databases/" data-href="https://fosdem.org/2019/schedule/event/hugepages_databases/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://fosdem.org/2019/schedule/event/hugepages_databases/"><strong class="markup--strong markup--mixtapeEmbed-strong">FOSDEM 2019 - Hugepages and databases</strong><br><em class="markup--em markup--mixtapeEmbed-em">The introduction of the 64-bit version of the x86 architecture allowed servers to operate with much larger amounts of…</em>fosdem.org</a><a href="https://fosdem.org/2019/schedule/event/hugepages_databases/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ecfc632c8e4f6e63e1d57402a1a38dde" data-thumbnail-img-id="0*1FxRzXoJSHSqCtpE" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*1FxRzXoJSHSqCtpE);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/7a97e7727b03"><time class="dt-published" datetime="2019-05-12T12:40:01.078Z">May 12, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/did-you-forget-to-allocate-huge-pages-on-your-postgresql-server-7a97e7727b03" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>