<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Oracle/Hibernate de-queuing</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Oracle/Hibernate de-queuing</h1>
</header>
<section data-field="subtitle" class="p-summary">
or how to use SELECT … FOR UPDATE SKIP LOCKED without any ROWNUM or FETCH FIRST ROWS in order to process a Job Queue in multi-thread
</section>
<section data-field="body" class="e-content">
<section name="339c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="92c9" id="92c9" class="graf graf--h3 graf--leading graf--title">Oracle/Hibernate de-queuing</h3><h4 name="f8d3" id="f8d3" class="graf graf--h4 graf-after--h3 graf--subtitle">or how to use SELECT … FOR UPDATE SKIP LOCKED without any ROWNUM or FETCH FIRST ROWS, but rather scroll() and setFetchSize() in order to process a job queue in multi-thread</h4><p name="6141" id="6141" class="graf graf--p graf-after--h4">This is a common problem: you have a queue of events that you want to process, like for example, application storing the e-mails to send, and a background job reading them, send the e-mail, and update the status from ‘to-do’ to ‘done’, when successful. There are some message queue specialized software, but a SQL table can be preferred, especially when the queuing is done by the database application: the same database means same Atomicity, Consistency, and Durability. And you want this robustness because you don’t want to miss an e-mail to send, and you don’t want to send duplicate e-mails.</p><p name="4aa8" id="4aa8" class="graf graf--p graf-after--p">But you can see that I’ve mentioned only the ACD of the ACID properties. You want a special thing about Isolation here. Because normal isolation would mean that you lock the rows that you process. But then, your de-queuing cannot be multi-threaded because all the others will wait on it. Oracle has the FOR UPDATE SKIP LOCKED exactly for that purpose: you don’t wait, you don’t stop, you just skip the row. This was documented lately (11g if I remember well) but it is there for a long time for internal use by Advanced Queuing.</p><p name="70b4" id="70b4" class="graf graf--p graf-after--p">In my opinion, even if it is documented we should take it with care, especially:</p><ul class="postList"><li name="269f" id="269f" class="graf graf--li graf-after--p">use it for what it is designed for — an AQ-like case</li><li name="007e" id="007e" class="graf graf--li graf-after--li">keep it simple and don’t tweak the limitations</li></ul><p name="fce2" id="fce2" class="graf graf--p graf-after--li">If you want to get an idea about the limitations, your google search should find those two links:</p><p name="540d" id="540d" class="graf graf--p graf-after--p">Jonathan Lewis:</p><div name="d3f2" id="d3f2" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://jonathanlewis.wordpress.com/2010/05/31/skip-locked/" data-href="https://jonathanlewis.wordpress.com/2010/05/31/skip-locked/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://jonathanlewis.wordpress.com/2010/05/31/skip-locked/"><strong class="markup--strong markup--mixtapeEmbed-strong">Skip Locked</strong><br><em class="markup--em markup--mixtapeEmbed-em">You may already be familiar with the syntax: It appeared (internally) some time back in Oracle 8i to implement some…</em>jonathanlewis.wordpress.com</a><a href="https://jonathanlewis.wordpress.com/2010/05/31/skip-locked/" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="e010c70c9b57f832555e856aca967fb6"></a></div><p name="56f3" id="56f3" class="graf graf--p graf-after--mixtapeEmbed">AskTOM:</p><div name="4ff4" id="4ff4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:9527937800346631524" data-href="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:9527937800346631524" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:9527937800346631524"><strong class="markup--strong markup--mixtapeEmbed-strong">Ask TOM SELECT FOR UPDATE SKIP LOCKED</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>asktom.oracle.com</a><a href="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:9527937800346631524" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="42f30f4fbd4a0dbf2cf6c451067fd652" data-thumbnail-img-id="0*jkmyylNftLB56NZr" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*jkmyylNftLB56NZr);"></a></div><p name="624f" id="624f" class="graf graf--p graf-after--mixtapeEmbed">In Jonathan Levis blog, you can see the problem when you want to use ROWNUM so that multiple threads can dequeue a small subset of rows to process. ROWNUM is evaluated before the FOR UPDATE. And then, two concurrent jobs will read the same rows. The first thread will take all of them and the second one will discard them. What you want is to limit the rows fetched after verifying that they are not locked by another session.</p><p name="ed98" id="ed98" class="graf graf--p graf-after--p">In the second link, Connor Mc Donalds shows how to do it properly: not limiting the query result, but only fetching the first rows. Connor’s example is in PL/SQL. My post here is to show the correct way from Hibernate.</p><p name="3115" id="3115" class="graf graf--p graf-after--p">Then you will add ‘Vlad’ to your google search an find:</p><div name="7d10" id="7d10" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://vladmihalcea.com/database-job-queue-skip-locked/" data-href="https://vladmihalcea.com/database-job-queue-skip-locked/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://vladmihalcea.com/database-job-queue-skip-locked/"><strong class="markup--strong markup--mixtapeEmbed-strong">How to implement a database job queue using SKIP LOCKED - Vlad Mihalcea</strong><br><em class="markup--em markup--mixtapeEmbed-em">Learn how to implement a job queue in a relational database system using the SKIP LOCKED row-level read or write…</em>vladmihalcea.com</a><a href="https://vladmihalcea.com/database-job-queue-skip-locked/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="72fd6edf3a4a111aa287d813ea5597d6" data-thumbnail-img-id="0*sJVDPCPO_VVQhd9n" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*sJVDPCPO_VVQhd9n);"></a></div><p name="233e" id="233e" class="graf graf--p graf-after--mixtapeEmbed">Vlad Mihalcea shows how to do it in general, but the implementation of SKIP LOCKED ROWS is very different from one database to the other. And, as explained above, with Oracle we should not mention a ‘ROWNUM&lt;’ or ‘FETCH FIRST ROWS’ or ‘row_number()’ to limit the result of a SKIP LOCKED. Actually, it can be tempting to mixing FOR UPDATE SKIP LOCKED with ROWNUM for row limitation, ORDER BY, and maybe even DBMS_RANDOM. But that’s too many non-deterministic operations that are very dangerous, especially for something as critical as job de-dequeuing.</p><h3 name="2b32" id="2b32" class="graf graf--h3 graf-after--p">The good example</h3><p name="b7f7" id="b7f7" class="graf graf--p graf-after--h3">I’ve built a small example with a simple MESSAGE table with an id and a flag. The rows are inserted with flag=0 and each thread will update the flag with its thread number.</p><p name="26c9" id="26c9" class="graf graf--p graf-after--p">Here is my Message class:</p><pre name="37e9" id="37e9" class="graf graf--pre graf-after--p">class Message {<br>    <a href="http://twitter.com/Id" data-href="http://twitter.com/Id" class="markup--anchor markup--pre-anchor" title="Twitter profile for @Id" rel="noopener" target="_blank">@Id</a><br>    <a href="http://twitter.com/GeneratedValue" data-href="http://twitter.com/GeneratedValue" class="markup--anchor markup--pre-anchor" title="Twitter profile for @GeneratedValue" rel="noopener" target="_blank">@GeneratedValue</a>(strategy=GenerationType.IDENTITY)<br>    private Long id;<br>    private Integer flag;<br>    public Long getId() {<br>        return id;<br>    }<br>    public void setId(Long id) {<br>        this.id = id;<br>    }<br>    public Integer getFlag() {<br>        return flag;<br>    }<br>    public void setFlag(Integer flag) {<br>        this.flag = flag;<br>    }<br>    <a href="http://twitter.com/Override" data-href="http://twitter.com/Override" class="markup--anchor markup--pre-anchor" title="Twitter profile for @Override" rel="noopener" target="_blank">@Override</a><br>    public boolean equals(Object o) {<br>        if (this == o) return true;<br>        if (!(o instanceof Message)) return false;<br>        Message message = (Message) o;<br>        return Objects.equals(getId(), message.getId());<br>    }<br>    <a href="http://twitter.com/Override" data-href="http://twitter.com/Override" class="markup--anchor markup--pre-anchor" title="Twitter profile for @Override" rel="noopener" target="_blank">@Override</a><br>    public int hashCode() {<br>        return Objects.hash(getId());<br>    }<br>}</pre><p name="c627" id="c627" class="graf graf--p graf-after--pre">And here is my de-queuing code:</p><pre name="eb7e" id="eb7e" class="graf graf--pre graf-after--p">s=sf.openSession();<br>Message message;<br>Transaction x;<br>x=s.beginTransaction();</pre><pre name="03ed" id="03ed" class="graf graf--pre graf-after--pre">ScrollableResults i = s.createQuery(&quot;from HibernateSkipLocked$Message where flag=0&quot;).setLockMode(LockModeType.PESSIMISTIC_WRITE).setHint(&quot;javax.persistence.lock.timeout&quot;,LockOptions.SKIP_LOCKED).setFetchSize(5).scroll(ScrollMode.FORWARD_ONLY);<br><br>int limit=5;</pre><pre name="853d" id="853d" class="graf graf--pre graf-after--pre">while( i.next() &amp;&amp; limit--&gt;0) {<br> message=(Message)i.get(0);<br> try { Thread.sleep(1000); } catch (Exception e) {}<br> message.setFlag(thread);<br> System.out.println(message.getId()+&quot; -&gt; &quot;+message.getFlag()+ &quot; &quot;+new Timestamp(System.currentTimeMillis()));<br>}</pre><pre name="a514" id="a514" class="graf graf--pre graf-after--pre">x.commit();<br>s.close();</pre><p name="0a46" id="0a46" class="graf graf--p graf-after--pre">And here are the what/why…</p><p name="482b" id="482b" class="graf graf--p graf-after--p">This will generate the FOR UPDATE:</p><pre name="f61c" id="f61c" class="graf graf--pre graf-after--p">.setLockMode(LockModeType.PESSIMISTIC_WRITE</pre><p name="3fde" id="3fde" class="graf graf--p graf-after--pre">This will generate the SKIP LOCKED:</p><pre name="3010" id="3010" class="graf graf--pre graf-after--p">.setHint(&quot;javax.persistence.lock.timeout&quot;,LockOptions.SKIP_LOCKED)</pre><p name="b030" id="b030" class="graf graf--p graf-after--pre">This will fetch 5 rows maximum for each fetch call (as my goal is to process 5 rows I don’t want the cursor to go further — as all fetched rows will be locked):</p><pre name="c4a2" id="c4a2" class="graf graf--pre graf-after--p">.setFetchSize(5)</pre><p name="ba95" id="ba95" class="graf graf--p graf-after--pre">This will get an iterator on the cursor. Do <strong class="markup--strong markup--p-strong">not</strong> use .list() because then all rows will be read and locked by the first thread and the next thread will have nothing to process:</p><pre name="fa9f" id="fa9f" class="graf graf--pre graf-after--p">.iterate()</pre><p name="a13d" id="a13d" class="graf graf--p graf-after--pre">This reads only 5 rows from the result:</p><pre name="7656" id="7656" class="graf graf--pre graf-after--p">int limit=5;<br>while( i.hasNext() &amp;&amp; limit--&gt;0)</pre><p name="5b8c" id="5b8c" class="graf graf--p graf-after--pre">That, combined with the fetch size, will ensure that we do one fetch call that finds 5 unlocked rows, lock them, return them. And we read and process those rows and stop (close the cursor) without another fetch call.</p><p name="54a5" id="54a5" class="graf graf--p graf-after--p">If you are not familiar with the LockModeType and LockOptions here is the query generated by Hibernate:</p><pre name="4316" id="4316" class="graf graf--pre graf-after--p">    select<br>        hibernates0_.id as col_0_0_<br>    from<br>        message hibernates0_<br>    where<br>        hibernates0_.flag=0 for update<br>            skip locked</pre><p name="9cd6" id="9cd6" class="graf graf--p graf-after--pre">The simpler the better here: FOR UPDATE SKIP LOCKED.</p><p name="5a69" id="5a69" class="graf graf--p graf-after--p">Here is a screenshot of the result, with my System.out.println in yellow showing the ids updated by thread 1 ( -&gt; 1 ) and thread 2 ( -&gt;2 ) at the same time.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="8217" id="8217" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 713px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 69.1%;"></div><img class="graf-image" data-image-id="1*9Aqo_GNpbucdmiwp7tBgtw.png" data-width="2251" data-height="1555" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*9Aqo_GNpbucdmiwp7tBgtw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="8768" id="8768" class="graf graf--p graf-after--figure">Now let’s show what happens if we don’t do that correctly</p><h3 name="fb96" id="fb96" class="graf graf--h3 graf-after--p">The bad example without SKIP LOCKED</h3><p name="9b8a" id="9b8a" class="graf graf--p graf-after--h3">Without SKIP LOCKED, the first thread locks the rows and the second one to read them waits on it — the threads are finally serialized:</p><pre name="3c99" id="3c99" class="graf graf--pre graf-after--p">java.util.Iterator i = s.createQuery(&quot;from HibernateSkipLocked$Message where flag=0&quot;).setLockMode(LockModeType.PESSIMISTIC_WRITE).setFetchSize(5).iterator();</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="942d" id="942d" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 517px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50.1%;"></div><img class="graf-image" data-image-id="1*gUYCBUxoXGqKu7Pi27W0uw.png" data-width="2733" data-height="1368" src="https://cdn-images-1.medium.com/max/1200/1*gUYCBUxoXGqKu7Pi27W0uw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="b21c" id="b21c" class="graf graf--h3 graf-after--figure">The ugly example with list() instead of scroll()</h3><p name="fb8f" id="fb8f" class="graf graf--p graf-after--h3">There’s a common misconception that the result is fully read when the query is executed. That’s not the normal behavior of the database. Where there’s no blocking operation (like GROUP BY or ORDER BY) the rows are read-only when needed. Yes, SQL RDBMS does lazy reads! Except when you explicitly read all rows to put them in a list, with list(). But in this case, the first thread locks all rows, even if it processes only 5 of them. And the second thread then skips all of them:</p><pre name="0eb9" id="0eb9" class="graf graf--pre graf-after--p">java.util.Iterator i = s.createQuery(&quot;from HibernateSkipLocked$Message where flag=0&quot;).setLockMode(LockModeType.PESSIMISTIC_WRITE).setHint(&quot;javax.persistence.lock.timeout&quot;,LockOptions.SKIP_LOCKED).setFetchSize(5).list().iterator();</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="9bde" id="9bde" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 418px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40.5%;"></div><img class="graf-image" data-image-id="1*o1r4EO3dA0h5eyhl3R5Abw.png" data-width="2713" data-height="1100" src="https://cdn-images-1.medium.com/max/1200/1*o1r4EO3dA0h5eyhl3R5Abw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="a10d" id="a10d" class="graf graf--h3 graf-after--figure">Order By</h3><p name="5c9b" id="5c9b" class="graf graf--p graf-after--h3">You may want to process rows in order. That should be rare because the goal of multi-threaded de-queuing is to process quickly so the order does not really matter. If you need a first-in-first-out then maybe you don’t want to multi-thread. And then add an ORDER BY but remove the SKIP LOCKED.</p><p name="c19b" id="c19b" class="graf graf--p graf-after--p">Be very careful if you add an ORDER BY to the HQL query above. You will see a warning and the SELECT separated from the FOR UPDATE SKIP LOCKED:</p><pre name="a815" id="a815" class="graf graf--pre graf-after--p">WARN: HHH000444: Encountered request for locking however dialect reports that database prefers locking be done in a separate select (follow-on locking); results will be locked after initial query executes</pre><pre name="3bca" id="3bca" class="graf graf--pre graf-after--pre">Hibernate:<br>    select<br>        hibernates0_.id as id1_0_,<br>        hibernates0_.flag as flag2_0_<br>    from<br>        message hibernates0_<br>    where<br>        hibernates0_.flag=0<br>    order by<br>        hibernates0_.id<br>Hibernate:<br>    select<br>        id<br>    from<br>        message<br>    where<br>        id =? for update<br>            skip locked</pre><p name="9b4d" id="9b4d" class="graf graf--p graf-after--pre">But then, that defeats the goal of multi-threading because we want to skip in the initial SELECT.</p><p name="27ed" id="27ed" class="graf graf--p graf-after--p">Then the idea is to fall back to a native query, here doing a last-in-first-out</p><pre name="5f10" id="5f10" class="graf graf--pre graf-after--p">ScrollableResults i = s.createNativeQuery(&quot;select * from message where flag=0 <strong class="markup--strong markup--pre-strong">order by id desc</strong> for update skip locked&quot;,Message.class).setFetchSize(5).scroll(ScrollMode.FORWARD_ONLY);</pre><p name="8f36" id="8f36" class="graf graf--p graf-after--pre">Here is the result where the thread 2 has taken id 14 to 10 and thread 1 then got id 9 to 5:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="de71" id="de71" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 614px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 59.5%;"></div><img class="graf-image" data-image-id="1*LcoCSA5ofeaASkbE3eNMBQ.png" data-width="2709" data-height="1613" src="https://cdn-images-1.medium.com/max/1200/1*LcoCSA5ofeaASkbE3eNMBQ.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="3b33" id="3b33" class="graf graf--h3 graf-after--figure">A few additional thoughts</h3><p name="1801" id="1801" class="graf graf--p graf-after--h3">While talking about the order, maybe you want an index on the flag that you use in the predicate. That’s useful if you don’t delete the rows processed but just update them. Because after a while a full table scan will have to read a big history of rows before finding those to process. Except if you can partition so that the processed ones are moved to another partition. Deleted rows leave the space for the new inserts and that’s really what we want here.</p><p name="a372" id="a372" class="graf graf--p graf-after--p">You can also plan the shuffling at the time of insertion. For example, adding a round-robin number (from a modulo or a cycle sequence) and each thread will be assigned a batch number.</p><p name="55b3" id="55b3" class="graf graf--p graf-after--p">Another consideration to keep in mind with queuing tables: the statistics. The queue is volatile by nature. You will probably prefer to lock the statistics. And if an unexpected de-queuing outage had made the queue grow larger than normal, then think about a SHRINK operation to lower the high water mark.</p><h4 name="7954" id="7954" class="graf graf--h4 graf-after--p">Updated 21-JUN-2019</h4><p name="840d" id="840d" class="graf graf--p graf-after--h4">You can see when looking at my Java code style, that I’m not a developer. So please read the feedback from Vlad Michalcea:</p><figure name="03a2" id="03a2" class="graf graf--figure graf--iframe graf-after--p"><blockquote class="twitter-tweet"><a href="https://twitter.com/vlad_mihalcea/status/1141955317217005568?s=20"></a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></figure><p name="ac55" id="ac55" class="graf graf--p graf-after--figure graf--trailing">I’ve updated this post to use scroll() instead if iterate() and the nice thing is that it works with native queries as well.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/7454432a7738"><time class="dt-published" datetime="2019-06-20T22:18:01.906Z">June 20, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/oracle-hibernate-de-queuing-7454432a7738" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>