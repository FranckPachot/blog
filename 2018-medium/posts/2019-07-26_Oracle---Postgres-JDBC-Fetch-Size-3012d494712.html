<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Oracle &amp; Postgres JDBC Fetch Size</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Oracle &amp; Postgres JDBC Fetch Size</h1>
</header>
<section data-field="subtitle" class="p-summary">
TL;DR —  By default PostgreSQL ResultSet is not a server cursor but a client buffer. The whole result is fetched before the first next()…
</section>
<section data-field="body" class="e-content">
<section name="bbbf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1a05" id="1a05" class="graf graf--h3 graf--leading graf--title">Oracle &amp; Postgres JDBC Fetch Size</h3><h4 name="d3a5" id="d3a5" class="graf graf--h4 graf-after--h3 graf--subtitle">TL;DR — By default PostgreSQL ResultSet is not a server cursor but a client buffer. The whole result is fetched before the first next() call.</h4><p name="54af" id="54af" class="graf graf--p graf-after--h4">It is usually a good idea to start with default settings rather than trying to ‘tune’ any possible parameter. Defaults are often suited to the most common cases. However, there’s a big exception to it when using JDBC drivers: the default fetch size is probably not the right setting. Here is an example with the same Java code to show the fetching behavior in Oracle and PostgreSQL.</p><h3 name="ab31" id="ab31" class="graf graf--h3 graf-after--p">Java example</h3><p name="2a25" id="2a25" class="graf graf--p graf-after--h3">Here is my Java code which is exactly the same for Oracle and PostgresSQL</p><pre name="9c4d" id="9c4d" class="graf graf--pre graf-after--p">import java.io.*;<br>import java.sql.*;<br>import java.util.*;<br>import java.time.*;<br>import oracle.jdbc.*;</pre><pre name="ca8e" id="ca8e" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">public class JDBC {<br></strong> public static void println(String text){<br>  System.out.println(Instant.now().toString() +&quot;:&quot; + text);<br> }<br> public static void main(String[] args)<br> throws SQLException,InterruptedException {<br>  try (<strong class="markup--strong markup--pre-strong">Connection c = (Connection) DriverManager.getConnection(<br>    args[2],args[0],args[1])</strong> // url, user, password<br>   ) {<br>   c.setAutoCommit(false);<br>   try (<strong class="markup--strong markup--pre-strong">PreparedStatement s = c.prepareStatement(<br>    &quot;select n,mytime(n) t from demo&quot;<br>    )</strong>) {<br>    <strong class="markup--strong markup--pre-strong">//</strong>s.setFetchSize(5);<br>    Thread.sleep(1000);<br>    println(&quot; PRS &quot;+s);<br>    try ( <strong class="markup--strong markup--pre-strong">ResultSet rs = s.executeQuery()</strong> ) {<br>     Thread.sleep(1000);<br>     println(&quot; EXE &quot;+rs);<br>     while ( <strong class="markup--strong markup--pre-strong">rs.next()</strong>) {<br>      Thread.sleep(1000);<br>      println(&quot; FCH &quot;+<strong class="markup--strong markup--pre-strong">rs.getLong</strong>(&quot;N&quot;)+&quot; &quot;+<strong class="markup--strong markup--pre-strong">rs.getTimestamp</strong>(&quot;T&quot;));<br>     }<br>     System.out.println(&quot;fetch size: &quot;+rs.getFetchSize());<br>    }<br>   }<br>  }<br> }<br><strong class="markup--strong markup--pre-strong">}</strong></pre><p name="bc7c" id="bc7c" class="graf graf--p graf-after--pre">This is very simple. The user, password and JDBC url are passed as arguments. The DriverManager finds the right driver for it (ojdbc8.jar and postgresql-jdbc.jar are in my CLASSPATH).</p><p name="cc1b" id="cc1b" class="graf graf--p graf-after--p">I prepare a simple select which I execute and fetch the rows. The query calls a “mytime()” stored function that returns the execution time timestamp, and waits one second for each call. The goal is to simulate a long query and show when the rows are actually read and when they are fetched.</p><h3 name="eb52" id="eb52" class="graf graf--h3 graf-after--p">Oracle JDBC Fetch Size</h3><p name="664c" id="664c" class="graf graf--p graf-after--h3">In order to run it on Oracle I create the following table and function:</p><pre name="fc70" id="fc70" class="graf graf--pre graf-after--p">alter session set current_schema=demo;<br> create or replace function mytime(n number) return timestamp as<br> begin<br>  dbms_session.sleep(1);<br>  return current_timestamp;<br> end;<br> /<br> show errors<br> create table demo (n int);<br> insert into demo<br>  select to_number(column_value) N from xmltable(&#39;1000 to 1020&#39;);<br> commit;</pre><figure name="160d" id="160d" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 431px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 61.6%;"></div><img class="graf-image" data-image-id="1*RN-xe2sx6_4w36gYm0w2xA.png" data-width="1314" data-height="809" src="https://cdn-images-1.medium.com/max/800/1*RN-xe2sx6_4w36gYm0w2xA.png"></div></figure><p name="eb3f" id="eb3f" class="graf graf--p graf-after--figure">The function is non-deterministic, and then it is executed for each row.</p><pre name="0494" id="0494" class="graf graf--pre graf-after--p">$ORACLE_HOME/jdk/bin/java JDBC &quot;demo&quot; &quot;demo&quot; &quot;jdbc:oracle:thin:@(DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=PDB1))(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))&quot;</pre><p name="7780" id="7780" class="graf graf--p graf-after--pre">Here is the result. Each fetch line shows the display timestamp first, and then the timestamp from the MYTIME() function which is the read time.</p><p name="e6e9" id="e6e9" class="graf graf--p graf-after--p">The Java program waits 1 second after each call: prepared at 18:33:10, executed at 18:33:21 — that’s a 10 second execution time. Then I fetched one row every second from 13:33:22 to 18:33:53:</p><figure name="9b8c" id="9b8c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 501px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 71.6%;"></div><img class="graf-image" data-image-id="1*5e8khiNqK-GsHqF7J5qtDQ.png" data-width="1331" data-height="953" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*5e8khiNqK-GsHqF7J5qtDQ.png"></div></figure><p name="d05f" id="d05f" class="graf graf--p graf-after--figure">With Oracle, the default JDBC fetch size is 10 rows, and the EXECUTE call also does the first fetch. Then here is the timing:</p><ul class="postList"><li name="3e11" id="3e11" class="graf graf--li graf-after--p">at 18:33:10 the prepareStatement is a very fast PARSE call as the actual optimization is deferred to the first execution.</li><li name="190b" id="190b" class="graf graf--li graf-after--li">at 18:33:22 the EXECUTE and first FETCH of the cursor occurs. Here it takes 10 seconds to get the first 10 rows. Those rows were read between 18:33:12 and 18:33:21, then fetched, then displayed between 18:33:22 and 18:33:31.</li><li name="b791" id="b791" class="graf graf--li graf-after--li">Then, the second FETCH call has read 10 more rows from 18:33:32 to 18:33:40 and displayed them from 18:33:42 to 18:33:51</li><li name="2fb5" id="2fb5" class="graf graf--li graf-after--li">Then one row remain: read, fetched and displayed.</li></ul><h3 name="1560" id="1560" class="graf graf--h3 graf-after--li">PostgreSQL default JDBC Fetch Size</h3><p name="c2b4" id="c2b4" class="graf graf--p graf-after--h3">Now I’ll run the same on a PostgreSQL database. In PostgreSQL, current_timestamp is consistent with the query time, then I use clock_timestamp() to get the actual read time.</p><pre name="8bfc" id="8bfc" class="graf graf--pre graf-after--p">\connect demo postgres<br> create table demo(n int);<br> insert into demo<br>  select generate_series from generate_series(1000,1020);<br> create function mytime(n int) returns timestamp as<br> $$<br> begin<br>  perform pg_sleep(1);<br>  return clock_timestamp();<br> end;<br> $$<br> language plpgsql;<br><br></pre><figure name="d7e0" id="d7e0" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 263px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 37.6%;"></div><img class="graf-image" data-image-id="1*MaZ9op_ekN5KSxdmV1bsog.png" data-width="1153" data-height="434" src="https://cdn-images-1.medium.com/max/800/1*MaZ9op_ekN5KSxdmV1bsog.png"></div></figure><p name="4105" id="4105" class="graf graf--p graf-after--figure">Here is the run with the same Java code:</p><pre name="749f" id="749f" class="graf graf--pre graf-after--p">\! $ORACLE_HOME/jdk/bin/java JDBC &quot;postgres&quot; &quot;demo&quot; &quot;jdbc:postgresql://localhost:5432/demo&quot;</pre><figure name="430f" id="430f" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 380px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 54.300000000000004%;"></div><img class="graf-image" data-image-id="1*V4OLxXDsLfPS2wStDyguZg.png" data-width="1316" data-height="714" src="https://cdn-images-1.medium.com/max/800/1*V4OLxXDsLfPS2wStDyguZg.png"></div></figure><p name="5ab4" id="5ab4" class="graf graf--p graf-after--figure">We don’t see any read-fetch pattern here and we have a clue with the fetch size that is set to zero by default. Rows were read from 18:36:07 to 18:36:27 and that matches with the executeQuery() time. All rows were read, and buffered, before displaying the first one. That’s the default behavior: the JDBC ResultSet is not a cursor but a buffer.</p><h3 name="939a" id="939a" class="graf graf--h3 graf-after--p">PostgreSQL JDBC set Fetch Size</h3><p name="54b5" id="54b5" class="graf graf--p graf-after--h3">In the Java code above, there’s a setFetchSize() in comments.</p><p name="87d7" id="87d7" class="graf graf--p graf-after--p">Here, I remove the comment to explicitly set the fetch size to 5 (for the demo, in real life you rather set 100 or 1000 to avoid too many roundtrips and context switches).</p><pre name="0037" id="0037" class="graf graf--pre graf-after--p">try (PreparedStatement s = c.prepareStatement(<br>    &quot;select n,mytime(n) t from demo&quot;<br>    )) {<br>    <strong class="markup--strong markup--pre-strong">s.setFetchSize(5);</strong></pre><p name="f030" id="f030" class="graf graf--p graf-after--pre">Here is the execution:</p><pre name="b119" id="b119" class="graf graf--pre graf-after--p">$ORACLE_HOME/jdk/bin/java JDBC &quot;postgres&quot; &quot;demo&quot; &quot;jdbc:postgresql://localhost:5432/demo&quot;</pre><figure name="601e" id="601e" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 392px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.00000000000001%;"></div><img class="graf-image" data-image-id="1*HrYFZPOgZ8vJAHFY1OhODA.png" data-width="1271" data-height="712" src="https://cdn-images-1.medium.com/max/800/1*HrYFZPOgZ8vJAHFY1OhODA.png"></div></figure><p name="02da" id="02da" class="graf graf--p graf-after--figure">There, we can see 5 rows read from 19:13:56 to 19:14:00 during the executeQuery() first FETCH, displayed from 19:14:02 to 19:14:06 and then again the same with 5 rows…</p><h3 name="155c" id="155c" class="graf graf--h3 graf-after--p">In summary</h3><p name="9dac" id="9dac" class="graf graf--p graf-after--h3">The behavior of the application can be really different.</p><p name="05f7" id="05f7" class="graf graf--p graf-after--p">The Oracle default has several advantages:</p><ul class="postList"><li name="4b1c" id="4b1c" class="graf graf--li graf-after--p">we have a real SQL Forward-Only cursor rather than a buffer</li><li name="c5d9" id="c5d9" class="graf graf--li graf-after--li">we can read a few rows from a large result. Like when de-queueing (<a href="https://medium.com/@FranckPachot/oracle-hibernate-de-queuing-7454432a7738" data-href="https://medium.com/@FranckPachot/oracle-hibernate-de-queuing-7454432a7738" class="markup--anchor markup--li-anchor" target="_blank">https://medium.com/@FranckPachot/oracle-hibernate-de-queuing-7454432a7738</a>) or Top-N results.</li><li name="3905" id="3905" class="graf graf--li graf-after--li">we can start to process the result without waiting for the completion</li></ul><p name="9755" id="9755" class="graf graf--p graf-after--li">However, it has also some drawbacks:</p><ul class="postList"><li name="b61e" id="b61e" class="graf graf--li graf-after--p">we can get an ORA-1555 if we read slowly and the MVCC retention has expired</li><li name="5b6d" id="5b6d" class="graf graf--li graf-after--li">we waste time in roundtrip and context switch latencies if we forget to increase the fetch size</li><li name="82bf" id="82bf" class="graf graf--li graf-after--li">we can get an execution error after having already processed some rows</li></ul><p name="14b4" id="14b4" class="graf graf--p graf-after--li">Note that if there is a blocking operation, like an ORDER BY that has to read the whole rows before returning the first one, the whole result is read and buffered on the server anyway.</p><p name="dffb" id="dffb" class="graf graf--p graf-after--p">PostgreSQL default seems to be more intuitive for today’s developers who are more used to lists than cursors. But this may change with the trend of streaming. The good thing is that you can choose. And anyway, in both case, the default (all rows for PostgreSQL, 10 rows for Oracle) is probably something to change in many cases.</p><p name="a783" id="a783" class="graf graf--p graf-after--p graf--trailing">Note that I’ve set AutoCommit to false, and this is required for the PostgreSQL cursor behavior when setting a non-zero fetch size, or it still buffers the whole rows. Anyway, that’s probably the worst JDBC default: never leave Auto Commit to true.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/3012d494712"><time class="dt-published" datetime="2019-07-26T21:16:57.908Z">July 26, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/oracle-postgres-jdbc-fetch-size-3012d494712" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>