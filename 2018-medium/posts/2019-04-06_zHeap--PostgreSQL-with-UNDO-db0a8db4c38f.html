<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>zHeap: PostgreSQL with UNDO</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">zHeap: PostgreSQL with UNDO</h1>
</header>
<section data-field="subtitle" class="p-summary">
I’m running on an Oracle Cloud Linux 7.6 VM provisioned as a sandbox so I don’t care about where it installs. For a better installation…
</section>
<section data-field="body" class="e-content">
<section name="adb5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8fac" id="8fac" class="graf graf--h3 graf--leading graf--title">zHeap: PostgreSQL with UNDO</h3><p name="91ea" id="91ea" class="graf graf--p graf-after--h3">I’m running on an Oracle Cloud Linux 7.6 VM provisioned as a sandbox so I don’t care about where it installs. For a better installation procedure, just look at Daniel Westermann script in:</p><div name="08ed" id="08ed" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blog.dbi-services.com/some-more-zheap-testing/" data-href="https://blog.dbi-services.com/some-more-zheap-testing/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.dbi-services.com/some-more-zheap-testing/"><strong class="markup--strong markup--mixtapeEmbed-strong">Some more zheap testing - Blog dbi services</strong><br><em class="markup--em markup--mixtapeEmbed-em">Hervé already did some tests with zheap and documented his results yesterday. After some more discussions with Amit who…</em>blog.dbi-services.com</a><a href="https://blog.dbi-services.com/some-more-zheap-testing/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c48f2815d3f63450a77ba9683b125009" data-thumbnail-img-id="0*htuRB85FV6fhT6H7" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*htuRB85FV6fhT6H7);"></a></div><p name="bd8a" id="bd8a" class="graf graf--p graf-after--mixtapeEmbed">The zHeap storage engine (in development) is provided by EnterpriseDB:</p><div name="a16e" id="a16e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/EnterpriseDB/zheap" data-href="https://github.com/EnterpriseDB/zheap" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/EnterpriseDB/zheap"><strong class="markup--strong markup--mixtapeEmbed-strong">EnterpriseDB/zheap</strong><br><em class="markup--em markup--mixtapeEmbed-em">new heap with in-place update, powered by undo, for eventual integration into PostgreSQL - EnterpriseDB/zheap</em>github.com</a><a href="https://github.com/EnterpriseDB/zheap" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c475b2aae5b8e3a7369bb544062adfce" data-thumbnail-img-id="0*fIi6O-A9JLRgTVrz" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*fIi6O-A9JLRgTVrz);"></a></div><p name="350e" id="350e" class="graf graf--p graf-after--mixtapeEmbed">I’ll also use pg_active_session_history, the ASH (Active Session History) approach for PostgreSQL, thanks to Bertrand Drouvot</p><div name="9c8e" id="9c8e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/pgsentinel/pgsentinel" data-href="https://github.com/pgsentinel/pgsentinel" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/pgsentinel/pgsentinel"><strong class="markup--strong markup--mixtapeEmbed-strong">pgsentinel/pgsentinel</strong><br><em class="markup--em markup--mixtapeEmbed-em">postgresql extension providing Active session history - pgsentinel/pgsentinel</em>github.com</a><a href="https://github.com/pgsentinel/pgsentinel" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bc1306abdb6ba12181bda5ff861126ec" data-thumbnail-img-id="0*AwwJiHwPv0uWy1T4" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*AwwJiHwPv0uWy1T4);"></a></div><p name="093b" id="093b" class="graf graf--p graf-after--mixtapeEmbed">In order to finish with the references, I’m running this on an Oracle Cloud compute instance (but you can run it anywhere).</p><div name="bf2b" id="bf2b" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://cloud.oracle.com/compute/virtual-machine/features" data-href="https://cloud.oracle.com/compute/virtual-machine/features" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://cloud.oracle.com/compute/virtual-machine/features"><strong class="markup--strong markup--mixtapeEmbed-strong">Cloud Computing VM Instances - Oracle Cloud Infrastructure</strong><br><em class="markup--em markup--mixtapeEmbed-em">Oracle Virtual Machines (VM) offer cloud computing resources in many shapes to meet a variety of workloads.</em>cloud.oracle.com</a><a href="https://cloud.oracle.com/compute/virtual-machine/features" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="34948fb8e503c496e3c9b98317de2d7a" data-thumbnail-img-id="0*JINLmUjYm4J5-Kt2" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*JINLmUjYm4J5-Kt2);"></a></div><p name="4d2c" id="4d2c" class="graf graf--p graf-after--mixtapeEmbed">Here is what I did on my OEL7 VM to get PostgreSQL with zHeap:</p><h4 name="1f5f" id="1f5f" class="graf graf--h4 graf-after--p"># Install and compile</h4><pre name="1bf0" id="1bf0" class="graf graf--pre graf-after--h4">sudo yum install -y git gcc readline-devel zlib-devel bison-devel<br>sudo mkdir -p /usr/local/pgsql<br>sudo chown $(whoami) /usr/local/pgsql<br>git clone <a href="https://github.com/EnterpriseDB/zheap" data-href="https://github.com/EnterpriseDB/zheap" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/EnterpriseDB/zheap</a><br>cd zheap &amp;&amp; ./configure --enable-debug &amp;&amp; make all &amp;&amp; make install<br>cd contrib &amp;&amp; make install<br>cd ../..</pre><h4 name="f1e7" id="f1e7" class="graf graf--h4 graf-after--pre"># Create a database</h4><p name="702a" id="702a" class="graf graf--p graf-after--h4"># Environment</p><pre name="1e81" id="1e81" class="graf graf--pre graf-after--p">export <strong class="markup--strong markup--pre-strong">PGDATA=/var/lib/pgsql/data</strong><br>echo &quot;$PATH&quot; | grep /usr/local/pgsql/bin || <br> export <strong class="markup--strong markup--pre-strong">PATH=&quot;$PATH:/usr/local/pgsql/bin&quot;</strong></pre><p name="9f91" id="9f91" class="graf graf--p graf-after--pre"># Creation of the database and start the server</p><pre name="566d" id="566d" class="graf graf--pre graf-after--p">initdb<br>pg_ctl start<br>ps -edf | grep postgres &amp;&amp; psql postgres &lt;&lt;&lt;&quot;\l\conninfo\;show server_version;&quot;</pre><p name="6450" id="6450" class="graf graf--p graf-after--pre"># Install pg_Sentinel extension</p><pre name="e0cb" id="e0cb" class="graf graf--pre graf-after--p">git clone <a href="https://github.com/pgsentinel/pgsentinel.git" data-href="https://github.com/pgsentinel/pgsentinel.git" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://github.com/pgsentinel/pgsentinel.git</a><br>cd pgsentinel/src &amp;&amp; make &amp;&amp; make install<br>cat &gt;&gt; $PGDATA/postgresql.conf &lt;&lt;CAT<br>shared_preload_libraries = &#39;pg_stat_statements,pgsentinel&#39;<br>track_activity_query_size = 2048<br>pg_stat_statements.track = all<br>CAT<br>psql postgres -c &quot;create extension pgsentinel;&quot;</pre><p name="001c" id="001c" class="graf graf--p graf-after--pre"># create a demo database</p><pre name="7f60" id="7f60" class="graf graf--pre graf-after--p">psql postgres -c &quot;create database demo;&quot;<br>psql demo     -c &quot;create extension pgsentinel;&quot;</pre><h4 name="6752" id="6752" class="graf graf--h4 graf-after--pre">Undo and discard workers</h4><p name="05ae" id="05ae" class="graf graf--p graf-after--h4">Here I am. Don’t worry about the user running it, that’s just me using what I already have there, but you can create a postgres user. I’m in a version 12 in development:</p><pre name="24d9" id="24d9" class="graf graf--pre graf-after--p">ps -edf | grep postgres &amp;&amp; psql postgres &lt;&lt;&lt;&quot;\l\conninfo\;show server_version;show config_file;&quot;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="4c5a" id="4c5a" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 547px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 53%;"></div><img class="graf-image" data-image-id="1*ay7f7eW7_C9vuP6--AWHTg.png" data-width="1058" data-height="561" src="https://cdn-images-1.medium.com/max/1200/1*ay7f7eW7_C9vuP6--AWHTg.png"></div><figcaption class="imageCaption">ps -edf | grep postgres &amp;&amp; psql postgres &lt;&lt;&lt;”\l\conninfo\;show server_version;show config_file;”</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="3ff8" id="3ff8" class="graf graf--h3 graf-after--figure">zHeap vs. Heap</h3><p name="f6c6" id="f6c6" class="graf graf--p graf-after--h3">In the past I measured the redo journaling (WAL) by PostgreSQL (<a href="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/" data-href="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/</a>) because, coming from Oracle, I was surprised by the amount of redo generated by some small updates in PostgreSQL. This overhead is due to the combination of two weaknesses: full page logging and no in-place update. The second will be partially addressed by zHeap, so let’s do the same test.</p><h4 name="bf72" id="bf72" class="graf graf--h4 graf-after--p">strace | awk</h4><p name="a357" id="a357" class="graf graf--p graf-after--h4">Here is the awk script I use to measure the volume written to disk</p><pre name="31b4" id="31b4" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">strace</strong> <strong class="markup--strong markup--pre-strong">-fye trace=write,pwrite64</strong> <strong class="markup--strong markup--pre-strong">-s 0</strong> <strong class="markup--strong markup--pre-strong">pg_ctl start</strong> 2&gt;&amp;1 &gt;/dev/null | awk &#39;<br>/^.<strong class="markup--strong markup--pre-strong">pid</strong> *[0-9]+. /{<br> pid=$2 ; sub(&quot;]&quot;,&quot;&quot;,pid)<br> &quot;cat /proc/&quot; pid &quot;/cmdline&quot; |&amp; getline cmdline<br> sub(/pid *[0-9]+/,sprintf(&quot;%-80s &quot;,cmdline))<br>}<br>/<strong class="markup--strong markup--pre-strong">pg_wal</strong>/ || /<strong class="markup--strong markup--pre-strong">undo</strong>/ {<br> sub(/[0-9A-Z]+&gt;/,&quot;...&gt;&quot;)<br>}<br>/<strong class="markup--strong markup--pre-strong">pwrite64</strong>[(].*, *[0-9]+, *[0-9]+[)]/{<br> sub(/, *[0-9]+[)].*/,&quot;&quot;)<br> bytes=$NF<br> $NF=&quot;&quot;<br> $0=$0&quot;,...)...&quot;<br> sub(/[(][0-9]+&lt;/,&quot;(...&lt;&quot;)<br> sum[$0]=sum[$0]+bytes<br> cnt[$0]=cnt[$0]+1<br> next<br>}<br>/<strong class="markup--strong markup--pre-strong">write</strong>[(].*, *[0-9]+[)]/{<br> sub(/[)].*/,&quot;&quot;)<br> bytes=$NF<br> $NF=&quot;&quot;<br> $0=$0&quot;)...&quot;<br> sub(/[(][0-9]+&lt;/,&quot;(...&lt;&quot;)<br> sum[$0]=sum[$0]+bytes<br> cnt[$0]=cnt[$0]+1<br> next<br>}<br>/^[^0-9]/{next}<br>{ print &gt; &quot;/dev/stderr&quot; }<br>END{<br> printf &quot;%9s%1s %6s %7s %s\n&quot;,&quot;BYTES&quot;,&quot;&quot;,&quot;COUNT&quot;,&quot;AVG&quot;,&quot;process/file&quot;<br> for (i in sum){<br> s=sum[i]<br> u=&quot; &quot;<br> if(s&gt;10*1024){s=s/1024;u=&quot;K&quot;}<br> if(s&gt;10*1024){s=s/1024;u=&quot;M&quot;}<br> if(s&gt;10*1024){s=s/1024;u=&quot;G&quot;}<br> if (cnt[i]&gt;1) printf &quot;%9d%1s %6d %7d %s\n&quot;,s,u,cnt[i],sum[i]/cnt[i],i<br> }<br>}<br>&#39; | sort -h</pre><p name="35a1" id="35a1" class="graf graf--p graf-after--pre">I strace the write calls (-e trace=write, pwrite64) without showing the data written (-s 0) when running the database server (pg_ctl start), tracing all child processes (-f) and showing the file names with the descriptor (-y). The awk keeps only the call, file, pid and bytes written to aggregate them. The pid is expanded with the process argv[0] for better readability.</p><h4 name="c4b2" id="c4b2" class="graf graf--h4 graf-after--p">Create zHeap table</h4><p name="dac3" id="dac3" class="graf graf--p graf-after--h4">Here is the table as in the previous blog post, but mentioning zHeap storage:</p><pre name="e9d6" id="e9d6" class="graf graf--pre graf-after--p">create table demoz <strong class="markup--strong markup--pre-strong">using zheap</strong> as select generate_series a,generate_series b,generate_series c,generate_series d,generate_series e,generate_series f,lpad(&#39;x&#39;,100,&#39;x&#39;) g from generate_series(0,0);</pre><pre name="a41c" id="a41c" class="graf graf--pre graf-after--pre">insert into demoz select generate_series a,generate_series b,generate_series c,generate_series d,generate_series e,generate_series f,lpad(&#39;x&#39;,100,&#39;x&#39;) g from generate_series(1,1000000);</pre><h4 name="e56e" id="e56e" class="graf graf--h4 graf-after--pre">Sparse update on one column</h4><p name="af2d" id="af2d" class="graf graf--p graf-after--h4">Here is the update that I wanted to test:</p><pre name="85d3" id="85d3" class="graf graf--pre graf-after--p">update demoz set b=b+1 where mod(a,10)=1;<br>UPDATE 100000</pre><p name="0f2a" id="0f2a" class="graf graf--p graf-after--pre">And the result of my strace|awk script on these 100000 updates:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="7f3b" id="7f3b" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 380px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 36.9%;"></div><img class="graf-image" data-image-id="1*k05jxYTXtASoibRuYs15YA.png" data-width="2420" data-height="892" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*k05jxYTXtASoibRuYs15YA.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e0b6" id="e0b6" class="graf graf--p graf-after--figure">- 4403+2047=1645 8k blocks, which is 112+15=<strong class="markup--strong markup--p-strong">127MB of data</strong><br> - 120+14=<strong class="markup--strong markup--p-strong">134MB of WAL</strong><br> - 15+14+2=<strong class="markup--strong markup--p-strong">31MB of UNDO</strong><br>The volume of undo is approximately the real volume of changes (I had 15MB of redo and 6MB of undo with same update on Oracle). But we still have an exaggerated volume of block changes (and with full-page logging).</p><p name="a77a" id="a77a" class="graf graf--p graf-after--p">I’ve created the same table in default Heap storage, and here is the write() trace for the same update:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="0f31" id="0f31" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 346px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.6%;"></div><img class="graf-image" data-image-id="1*I_3C1WE4GAs1tFPvbzeLAQ.png" data-width="2428" data-height="815" src="https://cdn-images-1.medium.com/max/1200/1*I_3C1WE4GAs1tFPvbzeLAQ.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="9ec6" id="9ec6" class="graf graf--p graf-after--figure">- 16191+4559+1897=22647 8k blocks, which is <strong class="markup--strong markup--p-strong">175MB of data</strong><br> - 131+33=<strong class="markup--strong markup--p-strong">164MB of WAL</strong></p><p name="cfaf" id="cfaf" class="graf graf--p graf-after--p graf--trailing">On this use case, which is quite common when we process data (call record, orders, …) and set only a flag or a date to mark them as processed, it seems that zHeap helps, but not a lot. But a real case would have many indexes on this table and updating in-place may reduce the overhead for non-updated columns. That’s for a future post.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/db0a8db4c38f"><time class="dt-published" datetime="2019-04-06T19:42:07.491Z">April 6, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/zheap-postgresql-with-undo-db0a8db4c38f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>