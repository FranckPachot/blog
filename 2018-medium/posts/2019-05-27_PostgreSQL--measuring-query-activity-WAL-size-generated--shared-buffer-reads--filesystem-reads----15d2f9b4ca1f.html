<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>PostgreSQL: measuring query activity(WAL size generated, shared buffer reads, filesystem reads,…)</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">PostgreSQL: measuring query activity(WAL size generated, shared buffer reads, filesystem reads,…)</h1>
</header>
<section data-field="subtitle" class="p-summary">
When I want to know if my application scales, I need to understand the work done by my queries. No need to run a huge amount of data from…
</section>
<section data-field="body" class="e-content">
<section name="bdab" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9ac6" id="9ac6" class="graf graf--h3 graf--leading graf--title">PostgreSQL: measuring query activity (WAL size generated, shared buffer reads, filesystem reads,…)</h3><p name="223b" id="223b" class="graf graf--p graf-after--h3">When I want to know if my application scales, I need to understand the work done by my queries. No need to run a huge amount of data from many concurrent threads. If I can get the relevant statistics behind a single unit-test, then I can infer how it will scale. For example, reading millions of pages to fetch a few rows will cause shared buffer contention. Or generating dozens of megabytes of WAL for a small update will wait on disk, and penalize the backup RTO, or the replication gap.</p><p name="29b3" id="29b3" class="graf graf--p graf-after--p">I’ll show some examples. From <strong class="markup--strong markup--p-strong">pgsql</strong> I’ll collect the statistics (which are cumulative from the start if the instance) before:</p><pre name="d2f5" id="d2f5" class="graf graf--pre graf-after--p">select *,<strong class="markup--strong markup--pre-strong">pg_current_wal_lsn</strong>() from <strong class="markup--strong markup--pre-strong">pg_stat_database</strong> where datname=current_database() <strong class="markup--strong markup--pre-strong">\gset</strong></pre><p name="bcfa" id="bcfa" class="graf graf--p graf-after--pre">and calculate the difference to show the delta:</p><pre name="124c" id="124c" class="graf graf--pre graf-after--p">select blks_hit-:blks_hit&quot;blk hit&quot;,blks_read-:blks_read&quot;blk read&quot;,tup_inserted-:tup_inserted&quot;ins&quot;,tup_updated-:tup_updated&quot;upd&quot;,tup_deleted-:tup_deleted&quot;del&quot;,tup_returned-:tup_returned&quot;tup ret&quot;,tup_fetched-:tup_fetched&quot;tup fch&quot;,xact_commit-:xact_commit&quot;commit&quot;,xact_rollback-:xact_rollback&quot;rbk&quot;,pg_size_pretty(<strong class="markup--strong markup--pre-strong">pg_wal_lsn_diff</strong>(<strong class="markup--strong markup--pre-strong">pg_current_wal_lsn</strong>(),:&#39;pg_current_wal_lsn&#39;)) &quot;WAL&quot;,pg_size_pretty(temp_bytes-:temp_bytes)&quot;temp&quot; from <strong class="markup--strong markup--pre-strong">pg_stat_database</strong> where datname=current_database();</pre><p name="dc20" id="dc20" class="graf graf--p graf-after--pre">Most of the statistics come from <a href="https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-DATABASE-VIEW" data-href="https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-DATABASE-VIEW" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pg_stat_database</a>. The WAL size is calculated from the latest WAL write pointer exposed with <a href="https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" data-href="https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pg_current_wal_lsn</a>() and size calculated with pg_wal_lsn_diff(). I use <strong class="markup--strong markup--p-strong">\gset</strong> to get them as <strong class="markup--strong markup--p-strong">plsql </strong>substitution variables before and used them to get the difference after.</p><p name="9fad" id="9fad" class="graf graf--p graf-after--p">Better with examples, I create a DEMO database and a DEMO table:</p><pre name="4aa1" id="4aa1" class="graf graf--pre graf-after--p">demo=# create table DEMO(n int primary key,flag char,text varchar(1000));</pre><pre name="dede" id="dede" class="graf graf--pre graf-after--pre">CREATE TABLE</pre><h3 name="ee94" id="ee94" class="graf graf--h3 graf-after--pre">Insert 1000 rows:</h3><p name="57b6" id="57b6" class="graf graf--p graf-after--h3">I’ve run the following insert:</p><pre name="94bb" id="94bb" class="graf graf--pre graf-after--p">insert into DEMO<br> select generate_series, &#39;N&#39;,lpad(&#39;x&#39;,1000,&#39;x&#39;) from generate_series(1,10000);<br>INSERT 0 10000</pre><p name="5527" id="5527" class="graf graf--p graf-after--pre">But I’ve run my queries before and after in order to get the statistics:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="3c94" id="3c94" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 314px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 30.4%;"></div><img class="graf-image" data-image-id="1*NmjgyLpggRB5Y6n3Oz8iqw.png" data-width="1878" data-height="571" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*NmjgyLpggRB5Y6n3Oz8iqw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="07af" id="07af" class="graf graf--p graf-after--figure">I’ve inserted about 10MB of data (10000 rows with a 1000 bytes text and some additional small columns). All those new rows bust be logged by the WAL, which is the reason for the 11MB of redo information. The pages where it was written had to be read from disks in order to update them, which is the reason for 1504 block reads (that’s about 11MB in 8k blocks). Actually, we see 30000 additional block hits in buffer cache and this is the index maintenance. Those 10000 rows were inserted one by one, updating the B*Tree index which may have a height of 3 and that’s 30000 pages touched. Fortunately, they stayed in the shared buffers which is why there’s no block read each time.</p><p name="313c" id="313c" class="graf graf--p graf-after--p">This matches with the size of my table:</p><pre name="66a2" id="66a2" class="graf graf--pre graf-after--p">select relkind,relname,relpages,pg_size_pretty(relpages::bigint*8*1024) from pg_class natural join (select oid relnamespace,nspname from pg_namespace) nsp where nspname=&#39;public&#39;;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="7a5b" id="7a5b" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 167px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 16.2%;"></div><img class="graf-image" data-image-id="1*-akpvDFnhHVK18AoJSuldA.png" data-width="1867" data-height="302" src="https://cdn-images-1.medium.com/max/1200/1*-akpvDFnhHVK18AoJSuldA.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="acb1" id="acb1" class="graf graf--p graf-after--figure">11MB of data, nearly 1500 pages — that’s what I got from the statistics.</p><h3 name="4501" id="4501" class="graf graf--h3 graf-after--p">Count the rows</h3><p name="e44a" id="e44a" class="graf graf--p graf-after--h3">Now, I’ll check how many blocks have to be read when counting all rows:</p><pre name="04bd" id="04bd" class="graf graf--pre graf-after--p">select count(*) from DEMO ;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="7809" id="7809" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 412px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 39.900000000000006%;"></div><img class="graf-image" data-image-id="1*VWaM8q1JOo7BOCQUB08SGQ.png" data-width="1873" data-height="747" src="https://cdn-images-1.medium.com/max/1200/1*VWaM8q1JOo7BOCQUB08SGQ.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="3ae2" id="3ae2" class="graf graf--p graf-after--figure">All table blocks were read, fortunately from the shared buffers. And the reason is in the explain plan: full table scan. Actually, I would expect an Index Only scan for this query because all rows can be counted from the index. But MVCC implementation of PostgreSQL is versioning only the table tuples. Not the index entries, and it has to go to the table, unless a recent vacuum has updated the visibility map.</p><h3 name="df55" id="df55" class="graf graf--h3 graf-after--p">Vacuum</h3><p name="9065" id="9065" class="graf graf--p graf-after--h3">Let’s vacuum to update the visibility map:</p><pre name="1cd7" id="1cd7" class="graf graf--pre graf-after--p">vacuum DEMO;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="028f" id="028f" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 233px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 22.6%;"></div><img class="graf-image" data-image-id="1*d68GeaR-H6exGXQ_lfuB8A.png" data-width="1877" data-height="424" src="https://cdn-images-1.medium.com/max/1200/1*d68GeaR-H6exGXQ_lfuB8A.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="8e08" id="8e08" class="graf graf--p graf-after--figure">Many block reads, that’s like a full table scan, with minimal updates here because there’s no dead tuples to remove.</p><h3 name="1616" id="1616" class="graf graf--h3 graf-after--p">Count from vacuumed table</h3><p name="ba07" id="ba07" class="graf graf--p graf-after--h3">Now, counting the rows again:</p><pre name="12b5" id="12b5" class="graf graf--pre graf-after--p">select count(*) from DEMO ;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="910e" id="910e" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 417px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40.400000000000006%;"></div><img class="graf-image" data-image-id="1*yRx97t12Mx-j6elzPLg1Eg.png" data-width="1870" data-height="755" src="https://cdn-images-1.medium.com/max/1200/1*yRx97t12Mx-j6elzPLg1Eg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="4d6c" id="4d6c" class="graf graf--p graf-after--figure">Finally I have a real Index Only scan, accessing only to 45 buffers to count the 10000 index entries. That’s the most important point with PostgreSQL performance: MVCC allows to mix read and write workloads, thanks to non-blocking reads, but ideally, a vacuum should occur between massive write and massive read use-cases. Again, no need to run a massive pgbench concurrent workload to observe this. Small queries are sufficient as long as we look at the right statistics.</p><h3 name="0b4a" id="0b4a" class="graf graf--h3 graf-after--p">Update</h3><p name="ea59" id="ea59" class="graf graf--p graf-after--h3">I update the ‘flag’ column to set half of the rows to ‘Y’:</p><pre name="f991" id="f991" class="graf graf--pre graf-after--p">update DEMO set flag=&#39;Y&#39; where n%2=0;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="148d" id="148d" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 246px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 23.9%;"></div><img class="graf-image" data-image-id="1*pFf-_aFtBbuXepB5A8p2eg.png" data-width="1873" data-height="447" src="https://cdn-images-1.medium.com/max/1200/1*pFf-_aFtBbuXepB5A8p2eg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="6aa8" id="6aa8" class="graf graf--p graf-after--figure">This is the operation where PostgreSQL MVCC is less efficient. I changed only one byte per row, but all rows were copied to new blocks. As I’m touching half the rows, they fit in half the blocks. This is the 743 read from disk. And the old version had to be marked as so… finally, nearly 30000 buffer access to update 5000 flags. And the worse is the redo generation. 16MB as the new tuples must be logged, as well as the old versions marked. And PostgreSQL must do full page logging even when few rows/columns are modified. More about this:</p><div name="e6a4" id="e6a4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/" data-href="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/"><strong class="markup--strong markup--mixtapeEmbed-strong">Full page logging in Postgres and Oracle - Blog dbi services</strong><br><em class="markup--em markup--mixtapeEmbed-em">By Franck Pachot . In my opinion, the volume of logging (aka redo log, aka xlog, aka WAL) is the most important factor…</em>blog.dbi-services.com</a><a href="https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="dbd3392ff899db5ef6fcb81a6c008e30" data-thumbnail-img-id="0*8DQ_b7l0LngFVjaO" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*8DQ_b7l0LngFVjaO);"></a></div><p name="2e80" id="2e80" class="graf graf--p graf-after--mixtapeEmbed">In this previous blog I was using <strong class="markup--strong markup--p-strong">strace</strong> to get the size of WAL written. Now using the delta offset of WAL pointer is see the same figures.</p><h3 name="3148" id="3148" class="graf graf--h3 graf-after--p">Delete</h3><p name="b2cb" id="b2cb" class="graf graf--p graf-after--h3">Now deleting the non-flagged rows</p><pre name="297e" id="297e" class="graf graf--pre graf-after--p">delete from DEMO where flag=&#39;N&#39;;</pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="42a8" id="42a8" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 233px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 22.5%;"></div><img class="graf-image" data-image-id="1*VAFXVSuoLAZFfHVLF8vMEg.png" data-width="1872" data-height="422" src="https://cdn-images-1.medium.com/max/1200/1*VAFXVSuoLAZFfHVLF8vMEg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="198f" id="198f" class="graf graf--p graf-after--figure">Deleting 5000 rows here, has to scan all blocks to find them (that’s the 10000 tuples returned) which is about 1500 buffers accessed. And for the 5000 found, mark them as deleted, which is 5000 additional buffers accessed.</p><h3 name="c132" id="c132" class="graf graf--h3 graf-after--p">Why?</h3><p name="5df5" id="5df5" class="graf graf--p graf-after--h3 graf--trailing">This post is there mainly to show the simple query I use to get SQL execution statistics, including WAL writes which are probably the most useful, but unfortunately missing from pg_stat_database. I’m also advocating here for small test cases fully understood rather than general benchmarks difficult to analyze. It is, in my opinion, the best way to understand how it works, both for educational purpose and to guarantee scalable applications.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/15d2f9b4ca1f"><time class="dt-published" datetime="2019-05-27T10:20:50.103Z">May 27, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/postgresql-measuring-query-activity-wal-size-generated-shared-buffer-reads-filesystem-reads-15d2f9b4ca1f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>