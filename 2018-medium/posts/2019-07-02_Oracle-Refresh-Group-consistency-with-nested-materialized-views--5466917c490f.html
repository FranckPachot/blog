<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Oracle Refresh Group consistency with nested materialized views.</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Oracle Refresh Group consistency with nested materialized views.</h1>
</header>
<section data-field="subtitle" class="p-summary">
A Refresh Group can be used to refresh a list of materialized views and ensures that all data is read with transaction consistency. This…
</section>
<section data-field="body" class="e-content">
<section name="3e44" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ea1d" id="ea1d" class="graf graf--h3 graf--leading graf--title">Oracle Refresh Group consistency with nested materialized views.</h3><p name="053e" id="053e" class="graf graf--p graf-after--h3">A Refresh Group can be used to refresh a list of materialized views and ensures that all data is read with transaction consistency. This post is about the meaning of consistency when one materialized view depends on the other one. That’s just a quick test to understand the behavior. Any comment is welcome (preferably on twitter — <a href="https://twitter.com/franckpachot" data-href="https://twitter.com/franckpachot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@FranckPachot</a>)</p><h3 name="696b" id="696b" class="graf graf--h3 graf-after--p">Documentation</h3><p name="ed32" id="ed32" class="graf graf--p graf-after--h3">The documentation mentions:</p><p name="f1ef" id="f1ef" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">To preserve referential integrity and transactional (read) consistency among multiple materialized views, Oracle Database can refresh individual materialized views as part of a refresh group. After refreshing all of the materialized views in a refresh group, the data of all materialized views in the group correspond to the same transactionally consistent point in time.</em></p><div name="fcd4" id="fcd4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://docs.oracle.com/cd/E11882_01/server.112/e10706/repmview.htm#REPLN109" data-href="https://docs.oracle.com/cd/E11882_01/server.112/e10706/repmview.htm#REPLN109" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.oracle.com/cd/E11882_01/server.112/e10706/repmview.htm#REPLN109"><strong class="markup--strong markup--mixtapeEmbed-strong">Materialized View Concepts and Architecture</strong><br><em class="markup--em markup--mixtapeEmbed-em">When a fast refresh is performed on a materialized view, Oracle must examine all of the changes to the master table or…</em>docs.oracle.com</a><a href="https://docs.oracle.com/cd/E11882_01/server.112/e10706/repmview.htm#REPLN109" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="49bcba8758dc75aeb5369cc9a467e391" data-thumbnail-img-id="0*Wx89gdHzG4mZdCSd" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Wx89gdHzG4mZdCSd);"></a></div><p name="2193" id="2193" class="graf graf--p graf-after--mixtapeEmbed">But what does that mean when one materialized view depends on the other? This can happen when we do a detailed aggregate, and then build finer aggregates from them. What I would like in this case is all materialized views showing data as it were at the same point-in-time in the original tables. But is that possible? Here is a little test.</p><h3 name="ef55" id="ef55" class="graf graf--h3 graf-after--p">Demo</h3><p name="a68d" id="a68d" class="graf graf--p graf-after--h3">I create a DEMO table where I’ll store a sequence number and a timestamp:</p><pre name="a28b" id="a28b" class="graf graf--pre graf-after--p">SQL&gt; connect demo/demo@//localhost/PDB1<br>Connected.<br>SQL&gt; set echo on<br>SQL&gt; create table DEMO as select 0 seq,current_timestamp now <br>     from xmltable(&#39;1 to 1000&#39;);</pre><pre name="f5ea" id="f5ea" class="graf graf--pre graf-after--pre">Table created.</pre><p name="5b53" id="5b53" class="graf graf--p graf-after--pre">I run a background job that will constantly increase the sequence number and update the timestamp:</p><pre name="307f" id="307f" class="graf graf--pre graf-after--p">SQL&gt; set escape on<br>SQL&gt; host { echo &quot;set echo on&quot; ; echo &quot;whenever sqlerror exit failure&quot; ; echo &quot;exec loop update demo set seq=seq+1,now=current_timestamp where rownum=1; commit; end loop;&quot; ; } | sqlplus -s demo/demo@//localhost/PDB1 \&amp; :</pre><pre name="7b01" id="7b01" class="graf graf--pre graf-after--pre">SQL&gt; host sleep 1;</pre><p name="c41d" id="c41d" class="graf graf--p graf-after--pre">This is a loop that updates at high rate, so do it in a noarchivelog database.</p><p name="e7cc" id="e7cc" class="graf graf--p graf-after--p">Now that I have this constantly changing table, I create a first materialized view DEMOMV1 which is just a select on DEMO:</p><pre name="cfe0" id="cfe0" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; create materialized view DEMOMV1 <br>              as select * from DEMO;</pre><pre name="0f13" id="0f13" class="graf graf--pre graf-after--pre">Materialized view created.</pre><pre name="5858" id="5858" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; select max(seq),max(now) <br>              from DEMOMV1;</pre><pre name="e5db" id="e5db" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      21393 01-JUL-19 12.17.07.221922000 PM GMT</pre><p name="0096" id="0096" class="graf graf--p graf-after--pre">This mview contains the original data as-of its creation time: SEQ=21393</p><p name="5604" id="5604" class="graf graf--p graf-after--p">And then I create DEMOMV2 that queries both the DEMO table and the DEMOMV1 materialized view, to show the consistency easily:</p><pre name="82bd" id="82bd" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; create materialized view DEMOMV2 as<br>              select &#39;MVIEW&#39; source,seq,now from DEMOMV1<br>              union all<br>              select &#39;TABLE&#39; source,seq,now from DEMO;</pre><pre name="cf35" id="cf35" class="graf graf--pre graf-after--pre">Materialized view created.</pre><pre name="61eb" id="61eb" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; select source,max(seq),max(now) <br>              from DEMOMV2 group by source;<br>   SOURCE    MAX(SEQ)                               MAX(NOW)<br>_________ ___________ ______________________________________<br>MVIEW           21393 01-JUL-19 12.17.07.221922000 PM GMT<br>TABLE           22099 01-JUL-19 12.17.07.336869000 PM GMT</pre><p name="3a5e" id="3a5e" class="graf graf--p graf-after--pre">I see the original data as-of two point in times:</p><ul class="postList"><li name="6a3c" id="6a3c" class="graf graf--li graf-after--p">DEMO table was read at the time of the creation of this DEMOMV2 mview, which contains data at this point-in-time where SEQ was 22099</li><li name="716c" id="716c" class="graf graf--li graf-after--li">DEMOMV1 was read at the time of the creation of this DEMOMV2 mview, which contain data from the last refresh of DEMOMV1, which means the original data when SEQ was 21393</li></ul><p name="3371" id="3371" class="graf graf--p graf-after--li">So far so good, this is exactly what I expected. The refreshes were done one after the other. I cannot expect to see the original data as of the same point-in-time.</p><h3 name="b58b" id="b58b" class="graf graf--h3 graf-after--p">Refresh Group</h3><p name="ee95" id="ee95" class="graf graf--p graf-after--h3">Here is the creation of the refresh group:</p><pre name="775e" id="775e" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; exec dbms_refresh.make(&#39;DEMO.DEMORGROUP&#39;, list=&gt;&#39;DEMOMV1,DEMOMV2&#39;, next_date=&gt;sysdate+100, interval=&gt;&#39;null&#39;);</pre><pre name="b3ff" id="b3ff" class="graf graf--pre graf-after--pre">PL/SQL procedure successfully completed.</pre><p name="ee72" id="ee72" class="graf graf--p graf-after--pre">and the current state of my tables:</p><pre name="454e" id="454e" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; select max(seq),max(now) from DEMO;</pre><pre name="fbc4" id="fbc4" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      22214 01-JUL-19 12.17.07.377349000 PM GMT</pre><pre name="e596" id="e596" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; select max(seq),max(now) from DEMOMV1;</pre><pre name="036b" id="036b" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      21393 01-JUL-19 12.17.07.221922000 PM GMT</pre><pre name="b8d0" id="b8d0" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; select source,max(seq),max(now) from DEMOMV2 group by source;</pre><pre name="c5f9" id="c5f9" class="graf graf--pre graf-after--pre">   SOURCE    MAX(SEQ)                               MAX(NOW)<br>_________ ___________ ______________________________________<br>MVIEW           21393 01-JUL-19 12.17.07.221922000 PM GMT<br>TABLE           22099 01-JUL-19 12.17.07.336869000 PM GMT</pre><pre name="0b01" id="0b01" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; select max(seq),max(now) from DEMO;</pre><pre name="500c" id="500c" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      22241 01-JUL-19 12.17.07.386421000 PM GMT</pre><p name="5392" id="5392" class="graf graf--p graf-after--pre">DEMO had some changes, but the materialized views are still at the same state as they were not refreshed.</p><p name="0be0" id="0be0" class="graf graf--p graf-after--p">Now refreshing the group (I enable some traces before):</p><pre name="b650" id="b650" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; alter session set tracefile_identifier=rgroup<br>              events=&#39;10979 trace name context forever, level 1<br>              : 10046 trace name context forever, level 3&#39;;</pre><pre name="9ec5" id="9ec5" class="graf graf--pre graf-after--pre">Session altered.</pre><pre name="cbd8" id="cbd8" class="graf graf--pre graf-after--pre">12:17:07 SQL&gt; exec dbms_refresh.refresh(&#39;DEMO.DEMORGROUP&#39;);</pre><pre name="12b6" id="12b6" class="graf graf--pre graf-after--pre">PL/SQL procedure successfully completed.</pre><p name="21bd" id="21bd" class="graf graf--p graf-after--pre">DEMO has newer sequence:</p><pre name="b02d" id="b02d" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; select max(seq),max(now) from DEMO;</pre><pre name="d95a" id="d95a" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      22713 01-JUL-19 12.17.07.532700000 PM GMT</pre><p name="387a" id="387a" class="graf graf--p graf-after--pre">Then I expect the materialize views to have been refreshed when DEMO was at a point where SEQ was between 22214 and 22713.</p><pre name="1ac0" id="1ac0" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; select max(seq),max(now) from DEMOMV1;</pre><pre name="fd8f" id="fd8f" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>      22507 01-JUL-19 12.17.07.464718000 PM GMT</pre><p name="f5e2" id="f5e2" class="graf graf--p graf-after--pre">That’s right, this refresh of DEMOMV1 occurred when SEQ was 22507.</p><p name="7c87" id="7c87" class="graf graf--p graf-after--p">Now the big question is about DEMOMV2:</p><pre name="2d7c" id="2d7c" class="graf graf--pre graf-after--p">12:17:07 SQL&gt; select source,max(seq),max(now) <br>              from DEMOMV2 group by source;</pre><pre name="3965" id="3965" class="graf graf--pre graf-after--pre">   SOURCE    MAX(SEQ)                               MAX(NOW)<br>_________ ___________ ______________________________________<br>MVIEW           22507 01-JUL-19 12.17.07.464718000 PM GMT<br>TABLE           22610 01-JUL-19 12.17.07.499890000 PM GMT</pre><p name="4dc0" id="4dc0" class="graf graf--p graf-after--pre">Same as when I did the refreshes manually, one by one: DEMOMV2 was refreshed after DEMOMV1 and sees DEMOMV1 as-of this point in time where SEQ was 22507. And data from the original table is fresher than that: SEQ was 22610 when DEMOMV2 was refreshed.</p><p name="d2f1" id="d2f1" class="graf graf--p graf-after--p">This means that if you build aggregates on top of aggregates, while the base table is changing, then the summaries will not show the aggregate data as-of the same point-in-time. It is perfectly normal that they are stale, but they don’t have the same staleness because they were nested.</p><h3 name="65d8" id="65d8" class="graf graf--h3 graf-after--p">Flashback query?</h3><p name="141a" id="141a" class="graf graf--p graf-after--h3">For a real consistency, I would have expected that DEMOMV2 had read DEMO as-of the same point-in-time as the other mviews in the refresh group. But here it behaved like a read-commited isolation level transaction: consistency is at statement level.</p><p name="17ac" id="17ac" class="graf graf--p graf-after--p">We can think of Flashback Query in this case. This would be fine to read DEMO. But reading DEMOMV1 with flashback query would ignore the changes done in the transaction, and I want to read the refreshed DEMOMV1 or I’ll get values from the previous refresh.</p><p name="d5bf" id="d5bf" class="graf graf--p graf-after--p">Anyway, flashback mode is disallowed here:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="2d17" id="2d17" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 353px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 34.2%;"></div><img class="graf-image" data-image-id="1*3DvywP7SSckiaPduuqQegA.png" data-width="1191" data-height="407" src="https://cdn-images-1.medium.com/max/1200/1*3DvywP7SSckiaPduuqQegA.png"></div><figcaption class="imageCaption">ORA-08182: operation not supported while in Flashback mode</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="1cc8" id="1cc8" class="graf graf--h3 graf-after--figure">Refresh order</h3><p name="d41b" id="d41b" class="graf graf--p graf-after--h3">We do not define any order when we add a materialized view to a refresh group. And, as we have seen, the order matters when one mview reads another one. The refresh group takes care of the dependencies as we can see in the 10979 trace:</p><figure name="807f" id="807f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 668px; max-height: 620px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 92.80000000000001%;"></div><img class="graf-image" data-image-id="1*b89M0dimqBBhLeeqlbsE0A.png" data-width="668" data-height="620" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*b89M0dimqBBhLeeqlbsE0A.png"></div></figure><p name="8c1d" id="8c1d" class="graf graf--p graf-after--figure">The ‘Sched. In’ and ‘Out’ link the dependencies. Here DEMOMV2 (which is #2 in the group) takes input from DEMOMV1 (which is #1) and then is scheduled after it.</p><p name="b1a5" id="b1a5" class="graf graf--p graf-after--p">Actually, in this example, the refresh works exactly as if I had refreshed DEMOMV2 with the nested option, triggering the refresh of the other mviews it depends on, like:</p><pre name="23b2" id="23b2" class="graf graf--pre graf-after--p">SQL&gt; exec dbms_mview.refresh(&#39;DEMO.DEMOMV2&#39;,nested=&gt;true);</pre><h3 name="69ea" id="69ea" class="graf graf--h3 graf-after--pre">Serializable</h3><p name="c7bb" id="c7bb" class="graf graf--p graf-after--h3">Finally, what I would have expected here is that the refresh was done in a SET TRANSACTION ISOLATION LEVEL SERIALIZABLE so that the refresh of DEMOMV2 sees DEMO at the same query SCN as when DEMOMV1 was refreshed, and sees DEMOMV1 as refreshed (uncommitted changes visible from the current transaction). Here is how it should work in my opinion, showing it with normal tables:</p><pre name="bec7" id="bec7" class="graf graf--pre graf-after--p">12:07:14 SQL&gt; set transaction isolation level serializable;</pre><pre name="8436" id="8436" class="graf graf--pre graf-after--pre">Transaction succeeded.</pre><pre name="ac01" id="ac01" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; delete from DEMOT1;</pre><pre name="3423" id="3423" class="graf graf--pre graf-after--pre">1 row deleted.</pre><pre name="bd3e" id="bd3e" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; insert into DEMOT1  select * from DEMO;</pre><pre name="b2c6" id="b2c6" class="graf graf--pre graf-after--pre">1 row created.</pre><pre name="93a1" id="93a1" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; delete from DEMOT2;</pre><pre name="8e3a" id="8e3a" class="graf graf--pre graf-after--pre">2 rows deleted.</pre><pre name="09e1" id="09e1" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; insert into DEMOT2 <br>              select &#39;MVIEW&#39; source,seq,now from DEMOT1 <br>              union all <br>              select &#39;TABLE&#39; source,seq,now from DEMO;</pre><pre name="be43" id="be43" class="graf graf--pre graf-after--pre">2 rows created.</pre><pre name="7bf2" id="7bf2" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; select max(seq),max(now) from DEMO;</pre><pre name="bfb4" id="bfb4" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>    2023485 02-JUL-19 12.07.14.394374000 PM GMT</pre><pre name="964e" id="964e" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; select max(seq),max(now) from DEMOT1;</pre><pre name="a914" id="a914" class="graf graf--pre graf-after--pre">   MAX(SEQ)                               MAX(NOW)<br>___________ ______________________________________<br>    2023485 02-JUL-19 12.07.14.394374000 PM GMT</pre><pre name="ec1f" id="ec1f" class="graf graf--pre graf-after--pre">12:07:14 SQL&gt; select source,max(seq),max(now) from DEMOT2 group by source;</pre><pre name="8c2a" id="8c2a" class="graf graf--pre graf-after--pre">   SOURCE    MAX(SEQ)                               MAX(NOW)<br>_________ ___________ ______________________________________<br>MVIEW         2023485 02-JUL-19 12.07.14.394374000 PM GMT<br>TABLE         2023485 02-JUL-19 12.07.14.394374000 PM GMT</pre><p name="d22a" id="d22a" class="graf graf--p graf-after--pre">This is what I would like to do with a materialized view refresh, but unfortunately:</p><figure name="1f0c" id="1f0c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 426px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 60.9%;"></div><img class="graf-image" data-image-id="1*C6XAlQCq7ej9bxOj92vaaw.png" data-width="1138" data-height="693" src="https://cdn-images-1.medium.com/max/800/1*C6XAlQCq7ej9bxOj92vaaw.png"></div><figcaption class="imageCaption">ORA-08177: can’t serialize access for this transaction</figcaption></figure><p name="302c" id="302c" class="graf graf--p graf-after--figure">This failed in the refresh of DEMOMV1:</p><pre name="8e6f" id="8e6f" class="graf graf--pre graf-after--p">/* MV_REFRESH (INS) */INSERT /*+ BYPASS_RECURSIVE_CHECK */ INTO &quot;DEMO&quot;.&quot;DEMOMV1&quot; select * from DEMO</pre><p name="80bf" id="80bf" class="graf graf--p graf-after--pre">About the reason, it doesn’t work as I would expect it, my guess is that it has something to do with: the fact that a refresh is somehow considered DDL:</p><figure name="a094" id="a094" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 148px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 21.099999999999998%;"></div><img class="graf-image" data-image-id="1*-nBn1UOLhA8gs_gCdBykFg.png" data-width="1389" data-height="293" src="https://cdn-images-1.medium.com/max/800/1*-nBn1UOLhA8gs_gCdBykFg.png"></div><figcaption class="imageCaption"><a href="https://asktom.oracle.com/pls/asktom/asktom.search?tag=refresh-on-materialized-view#152095200346634471" data-href="https://asktom.oracle.com/pls/asktom/asktom.search?tag=refresh-on-materialized-view#152095200346634471" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://asktom.oracle.com/pls/asktom/asktom.search?tag=refresh-on-materialized-view#152095200346634471</a></figcaption></figure><p name="900e" id="900e" class="graf graf--p graf-after--figure graf--trailing">So… be careful if you have materialized views on top on the other, and want a consistent refresh, and the base tables are changing. And test it. The consistency issues are always discovered too late in production. Do you have UAT checking that?</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/5466917c490f"><time class="dt-published" datetime="2019-07-02T14:56:05.739Z">July 2, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/oracle-refresh-group-consistency-with-nested-materialized-views-5466917c490f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>