<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Ideas for Event Sourcing in Oracle</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Ideas for Event Sourcing in Oracle</h1>
</header>
<section data-field="subtitle" class="p-summary">
Log Miner or are there other alternatives?
</section>
<section data-field="body" class="e-content">
<section name="e53e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e1bd" id="e1bd" class="graf graf--h3 graf--leading graf--title">Ideas for Event Sourcing in Oracle</h3><h4 name="309a" id="309a" class="graf graf--h4 graf-after--h3 graf--subtitle">Log Miner or are there other alternatives?</h4><p name="c0ff" id="c0ff" class="graf graf--p graf-after--h4">With microservices, the architects want to dismantle the monolithic database and replicate data rather than share it. Then raises the need to audit the changes where the modifications are done (like the C in <a href="https://martinfowler.com/bliki/CQRS.html" data-href="https://martinfowler.com/bliki/CQRS.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CQRS</a>). The Oracle database already does that for recovery purpose, building the redo records before modifying the data blocks, but that’s a physical change vector. We need something logical with more possibilities to filter and transform. There are multiple possible methods for this. But unfortunately, the ones that were built in the database are slowly removed since Oracle has acquired Golden GAte and sells it separately.</p><ul class="postList"><li name="9c30" id="9c30" class="graf graf--li graf-after--p"><a href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60159" data-href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60159" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Streams is deprecated in 12c</a></li><li name="ce9c" id="ce9c" class="graf graf--li graf-after--li"><a href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60084" data-href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60084" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Advanced Replication is deprecated in 12c</a></li><li name="f699" id="f699" class="graf graf--li graf-after--li"><a href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60014" data-href="https://docs.oracle.com/database/121/UPGRD/deprecated.htm#UPGRD60014" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Change Data Capture is deprecated in 12c</a></li><li name="f74d" id="f74d" class="graf graf--li graf-after--li"><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/upgrd/behavior-changes-deprecated-desupport-oracle-database.html#GUID-87A754A3-AC6B-4F84-8C36-AB90AC5032D4" data-href="https://docs.oracle.com/en/database/oracle/oracle-database/19/upgrd/behavior-changes-deprecated-desupport-oracle-database.html#GUID-87A754A3-AC6B-4F84-8C36-AB90AC5032D4" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">LogMiner Continuous Mine is deprecated in 12c</a></li></ul><p name="c5c6" id="c5c6" class="graf graf--p graf-after--li">And deprecated became desupported, and even removed in further releases, like Continuous Mine in 19c — the final pathset of 12cR2:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="aeaf" id="aeaf" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 118px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 11.5%;"></div><img class="graf-image" data-image-id="0*Xk7UUBjRJE8PIa4l" data-width="1388" data-height="159" src="https://cdn-images-1.medium.com/max/1200/0*Xk7UUBjRJE8PIa4l"></div><figcaption class="imageCaption">ORA-44609: CONTINOUS_MINE is desupported for use with DBMS_LOGMNR.START_LOGMNR</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="5140" id="5140" class="graf graf--p graf-after--figure">The doc says that the replacement is Golden Gate but that’s another product to buy, very powerful but expensive (and there’s no Standard Edition).</p><h4 name="bf8b" id="bf8b" class="graf graf--h4 graf-after--p">Debezium DBZ-137</h4><p name="6b7a" id="6b7a" class="graf graf--p graf-after--h4"><a href="http://Debezium" data-href="http://Debezium" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Debezium</a>, an open source distributed platform for change data capture, is working on an Oracle Database connector. Many ideas are mentioned in <a href="https://issues.jboss.org/browse/DBZ-137" data-href="https://issues.jboss.org/browse/DBZ-137" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://issues.jboss.org/browse/DBZ-137</a> and in this post I give my thought about them.</p><div name="dcab" id="dcab" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://issues.jboss.org/browse/DBZ-137" data-href="https://issues.jboss.org/browse/DBZ-137" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://issues.jboss.org/browse/DBZ-137"><strong class="markup--strong markup--mixtapeEmbed-strong">[DBZ-137] Ingest change data from Oracle databases using LogMiner - JBoss Issue Tracker</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>issues.jboss.org</a><a href="https://issues.jboss.org/browse/DBZ-137" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a5e40234570fb358556f99d818ba6da5" data-thumbnail-img-id="0*y_zmd2fjnmg38hMn" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*y_zmd2fjnmg38hMn);"></a></div><h4 name="955f" id="955f" class="graf graf--h4 graf-after--mixtapeEmbed">Oracle XStreams</h4><p name="20f8" id="20f8" class="graf graf--p graf-after--h4">The perfect solution as it has minimal overhead on the source and is very efficient. But it requires Golden Gate licensing, and then is probably not the best solution for an Open Source product.</p><h4 name="04c5" id="04c5" class="graf graf--h4 graf-after--p">Oracle LogMiner</h4><p name="4a3a" id="4a3a" class="graf graf--p graf-after--h4">LogMiner is included in all Editions, reads the redo stream (archived and online redo logs) and extracts all information. When enabling Supplemental Logging, we have enough information to build the logical change information. Many solutions are already based on that. But I see two problems with it.</p><p name="3114" id="3114" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">LogMiner Limits:</strong> Basically, LogMiner was not made for replication. The idea was more to give a troubleshooting tool to understand what happened on the data: what is generating too much redo? Who deleted some data? Which sessions were locking rows?… There are limits, like unsupported datatypes. And it is not designed to be efficient. But there’s also the possibility to mine on another system. However, I think that those limits can be acceptable for an Open Source solution on simple databases with low rate of changes.</p><p name="62f7" id="62f7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">LogMiner Future</strong>: What is more wondering is how Oracle removes the features that may give an alternative to Golden Gate. In 19c the CONTINUOUS_MINE was removed. This means that we need to constantly open and read the whole the redo logs. And do we know what Oracle will remove in future versions when they will see a robust Open Source product that competes with Golden Gate?</p><p name="ec93" id="ec93" class="graf graf--p graf-after--p">On the DBZ-137 there are some remarks about RAC which is more complex because there are many redo threads. I don’t think that RAC is in the scope for this. RAC is an expensive option that is required only on large databases with very high load. That fits more in the Golden Gate scope.</p><p name="2873" id="2873" class="graf graf--p graf-after--p">Note that we can parse the SQL_REDO and SQL_UNDO from V$LOGMINER_CONTENTS but there’s also the possibility to get them from <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_LOGMNR.html#GUID-F601D8C4-0A79-467C-9A9F-BFC6BB725B31" data-href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_LOGMNR.html#GUID-F601D8C4-0A79-467C-9A9F-BFC6BB725B31" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">dbms_logmnr.mine_value</a></p><h4 name="2021" id="2021" class="graf graf--h4 graf-after--p">Mining the binary log stream</h4><p name="9d33" id="9d33" class="graf graf--p graf-after--h4">There are some attempts to mine the binary redo logs. Some well known commercial products and some Open Source attempts. That’s very complex, but that’s also fun for an open source community. The redo log structure is proprietary but Oracle will not change it too often because all availability features (recovery, standby,…) are based on it. However, there may be a legal issue to open source this mining as it exposes the proprietary format of the redo. Reverse engineering is clearly forbidden by the Oracle license.</p><h4 name="7e3b" id="7e3b" class="graf graf--h4 graf-after--p">Continuous Query Notification</h4><p name="8060" id="8060" class="graf graf--p graf-after--h4">I studied the usage of dbms_change_notification as a CDC alternative: <a href="https://blog.dbi-services.com/event-sourcing-cqn-is-not-a-replacement-for-cdc/" data-href="https://blog.dbi-services.com/event-sourcing-cqn-is-not-a-replacement-for-cdc/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://blog.dbi-services.com/event-sourcing-cqn-is-not-a-replacement-for-cdc</a>. This feature is aimed at nearly static data, in order to invalidate and refresh a cache. It is not designed for a high change rate and is not efficient at all for this.</p><h4 name="abe5" id="abe5" class="graf graf--h4 graf-after--p">Client Result Cache</h4><p name="b829" id="b829" class="graf graf--p graf-after--h4">In the same idea as refreshing a cache from data that do not change often, one can think about querying with client result cache as it has a mechanism to invalidate the cache when a modification occurs. However, the granularity is bad here as any change on the table will invalidate all queries on it.</p><h4 name="f0c4" id="f0c4" class="graf graf--h4 graf-after--p">Materialized View Logs</h4><p name="d6bb" id="d6bb" class="graf graf--p graf-after--h4">All changes can be logged in materialized view logs. This feature is built for materialized views fast refresh which is a kind of replication. This has nothing to do with the redo log used by LogMiner. With materialized view logs, the changes are stored in a table and must be deleted when consumed. But this feature exists for a long time and is widely used. However, I would seriously question the architecture if there’s a general need for double writing, then reading it and deleting it, just to put the same data into another place.</p><h4 name="b1d2" id="b1d2" class="graf graf--h4 graf-after--p">Triggers</h4><p name="7a55" id="7a55" class="graf graf--p graf-after--h4">With triggers, we can log the changes as with materialized view logs. It gives more possibilities, like sending the change rather than storing it in the database (but then we have to manage the transaction visibility). An optimized example to store the audited change has been published by Connor McDonald:</p><div name="ea32" id="ea32" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://blogs.oracle.com/oraclemagazine/a-fresh-look-at-auditing-row-changes" data-href="https://blogs.oracle.com/oraclemagazine/a-fresh-look-at-auditing-row-changes" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blogs.oracle.com/oraclemagazine/a-fresh-look-at-auditing-row-changes"><strong class="markup--strong markup--mixtapeEmbed-strong">A Fresh Look at Auditing Row Changes</strong><br><em class="markup--em markup--mixtapeEmbed-em">By Connor McDonald March/April 2016 Barbara is looking forward to a long-overdue vacation. She&#39;s been working extremely…</em>blogs.oracle.com</a><a href="https://blogs.oracle.com/oraclemagazine/a-fresh-look-at-auditing-row-changes" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1a876a1a83ae9bb477d1234f79566895" data-thumbnail-img-id="0*KoFMt20xMJUqZVCP" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*KoFMt20xMJUqZVCP);"></a></div><p name="0038" id="0038" class="graf graf--p graf-after--mixtapeEmbed">But this is still a lot of overhead and need to to be adapted when columns are added or removed.</p><h4 name="2e48" id="2e48" class="graf graf--h4 graf-after--p">ORA_ROWSCN</h4><p name="f16c" id="f16c" class="graf graf--p graf-after--h4">When we enable row dependencies, the ORA_ROWSCN pseudo-column can help to filter the rows that may have been updated recently. However, there are two problems with this approach.</p><p name="10a9" id="10a9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">full read</strong>: if we want a near real-time replication, we will probably pool for changes frequently. ORA_ROWSCN would be nice if indexed, but that’s not the case. It just reads the information stored in the table block. That means that to find the changes done in the last 5 minutes we need to full scan the table and ORA_ROWSCN will then help to identify those rows that were changed. It is a transparent alternative to a “last update” column timestamp but does not help to access quickly to those rows.</p><p name="a2bc" id="a2bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">commit time</strong>: there’s a general problem with anything that reads a “change” timestamp. Let’s say that I pool the changes every 5 minutes. I have a long transaction that updates a row at 12:39 and commits at 12:42. The pool that runs at 12:40, looking for changes since 12:35, does not see the change as it is not committed yet. The pool that runs at 12:45 can see it but not when it filters on the changes that occurred since the last run, which is 12:20. This means that each run must look on a larger window, including the longest transaction start. And then it must deal with duplicates as some of the changes have been captured by the previous run. This is a general problem when there’s no “commit SCN” available.</p><h4 name="f7f0" id="f7f0" class="graf graf--h4 graf-after--p">Userenv(‘commitscn’)</h4><p name="f4e3" id="f4e3" class="graf graf--p graf-after--h4">While talking about the visibility time (commit SCN) vs. the change there is an undocumented way to get it. insert or update with userenv(‘commitscn’) and this will magically get back to the table row at the end of the transaction to set the Commit SCN. It is not supported and anyway it can be invoked only once in a transaction and then cannot be added automatically in a trigger.</p><h4 name="d202" id="d202" class="graf graf--h4 graf-after--p">Oracle Flashback Query</h4><p name="b945" id="b945" class="graf graf--p graf-after--h4">If we don’t want to add additional auditing on DML, the redo log is not the only internal logging. Oracle also logs the undo information for consistent reads (MVCC) and this, without any additional overhead on the modification, can show all changes that occurred in a table. Basically, we can SELECT … FROM … VERSION BETWEEN SCN … AND … and all changes will be visible with the new and old values and additional information about the operation and the transaction.</p><p name="fe17" id="fe17" class="graf graf--p graf-after--p">However, this is not indexed. Like with ORA_ROWSCN we need to full scan the table and the consistent read will build the previous versions of the blocks, thanks to the undo.</p><h4 name="a382" id="a382" class="graf graf--h4 graf-after--p">Flashback Data Archive</h4><p name="9165" id="9165" class="graf graf--p graf-after--h4">Flashback Query can reconstruct the recent changes, limited by the undo retention, and by the last DDL that occurred. Flashback Data Archive (which was called Total Recall) can go further. This feature is available in Enterprise Edition without the need for an additional option. It can go beyond the undo retention and allows some DDL. But, again, it is not optimized to get all changes since a specific point in time. The idea is that when you know the rows you want to read, then it can get to the previous version.</p><h3 name="425d" id="425d" class="graf graf--h3 graf-after--p">Minimal trigger + flashback query</h3><p name="4972" id="4972" class="graf graf--p graf-after--h3">Some of those solutions can be combined. For example, a trigger can log only the ROWID of the changed rows and the replication process will get more information for these rows through flashback query. This lowers the overhead on the changes, while still avoiding a full scan for the replication. Or you may get those ROWID directly from custom-mining the redo logs, which is much simple than trying to get all information from it.</p><h3 name="31d0" id="31d0" class="graf graf--h3 graf-after--p">DDL triggers</h3><p name="549e" id="549e" class="graf graf--p graf-after--h3">SQL is agile and allows the structure to change. If adding a column breaks the whole replication, then we have a problem. All the solutions above need to handle those changes. The redo log contains the changes in the dictionary, but it can be complex to decode. All other solution must adapt to those changes and that means having a DDL trigger and handling the different kinds of changes.</p><h3 name="d36a" id="d36a" class="graf graf--h3 graf-after--p">Not easy…</h3><p name="6f6e" id="6f6e" class="graf graf--p graf-after--h3">The summary is that there are no easy solutions, and the easiest ones have been removed by Oracle to push the sales for Golden Gate. My first recommendation when someone wants to replicate to changes to query it from another place is: <strong class="markup--strong markup--p-strong">don’t do that</strong>. Relational databases are made to ingest new data and modifications, and be able to query for different purposes. We have views to show data in different formats. We have indexes to get fast access for different use cases. Oracle is not like many of its competitors. It has been optimized for mixed workloads from the first versions. You can query the same database where the changes occur because a SELECT does not lock anything. You have a resource manager to be sure that runaway queries cannot slow down the transactional activity. And the CPU usage for those queries, when correctly tuned, will rarely be higher than the replication activity you need to implement to stream the changes to another database.</p><p name="ed4b" id="ed4b" class="graf graf--p graf-after--p">Then, which technology should an event sourcing be built upon? LogMiner looks good for small databases with basic usage. And the project should adapt to the features that are removed by Oracle in the future.</p><h4 name="de09" id="de09" class="graf graf--h4 graf-after--p">Hybrid trigger / flashback query</h4><p name="6d3d" id="6d3d" class="graf graf--p graf-after--h4">When only a few tables are concerned, generating DML triggers is probably the simplest, especially if they log only the minimum, like the ROWID. The ROWID will be visible only when the transaction is committed. Then the replication process must use flashback query, reading only those blocks from the ROWID. The nice thing here is that flashback query shows when the change was visible (the commit time) rather than the change time, which makes it easier to filter out the changes already processed by the last run.</p><p name="a53a" id="a53a" class="graf graf--p graf-after--p">Here is the idea when a trigger has logged the ROWID changed into a DEMO_CDC table, and we query:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="5d40" id="5d40" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 281px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 27.200000000000003%;"></div><img class="graf-image" data-image-id="1*2DTekTd2oWxHkE73lQzLQw.png" data-width="2514" data-height="684" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*2DTekTd2oWxHkE73lQzLQw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="0cc4" id="0cc4" class="graf graf--p graf-after--figure">The execution plan for this shows optimal access with the ROWID:</p><pre name="02c2" id="02c2" class="graf graf--pre graf-after--p">Explain Plan<br>------------------------------------------------<br>PLAN_TABLE_OUTPUT<br>Plan hash value: 3039832324</pre><pre name="429c" id="429c" class="graf graf--pre graf-after--pre">------------------------------------------------<br>| Id  | Operation                   | Name     |<br>------------------------------------------------<br>|   0 | SELECT STATEMENT            |          |<br>|   1 |  NESTED LOOPS               |          |<br>|   2 |   SORT UNIQUE               |          |<br>|   3 |    TABLE ACCESS FULL        | DEMO_CDC |<br>|   4 |   TABLE ACCESS BY USER ROWID| DEMO     |<br>------------------------------------------------</pre><p name="9426" id="9426" class="graf graf--p graf-after--pre">The important thing here is that the query cost is proportional to the changes and not to the full size of the table. And the trigger overhead is limited to the ROWID only. There’s no need to store in a table the values that are stored already in the base table and the undo segments. If reading this is done frequently, there are good chances that all blocks involved (the ROWID list, the UNDO records and the table block) are still in the buffer cache.</p><p name="38c4" id="38c4" class="graf graf--p graf-after--p graf--trailing">This trigger+flashback approach is just an idea that I’ve never used. So feedbacks welcome on <a href="https://twitter.com/franckpachot" data-href="https://twitter.com/franckpachot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://twitter.com/franckpachot</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/d4e016e90af6"><time class="dt-published" datetime="2019-07-15T15:33:35.235Z">July 15, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/ideas-for-event-sourcing-in-oracle-d4e016e90af6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>