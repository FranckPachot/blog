<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>UUID (aka GUID) vs. Oracle sequence number</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">UUID (aka GUID) vs. Oracle sequence number</h1>
</header>
<section data-field="subtitle" class="p-summary">
When you want to generate a unique number, for a primary key, the most common idea (and the right one) is to get a number from an always…
</section>
<section data-field="body" class="e-content">
<section name="c5a0" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3f8b" id="3f8b" class="graf graf--h3 graf--leading graf--title">UUID (aka GUID) vs. Oracle sequence number</h3><p name="8ec7" id="8ec7" class="graf graf--p graf-after--h3">When you want to generate a unique number, for a primary key, the most common idea (and the right one) is to get a number from an always increasing generator. Oracle provides SEQUENCE for this purpose, which is optimized, easy to use and scalable.</p><p name="26a6" id="26a6" class="graf graf--p graf-after--p">But some application developer has the idea to use a UUID (Universally Unique Identifier) also known as GUID (Globally Unique Identifier). The main advantage is that you do not need a shared object like a sequence because there is no need for a central authority. UUID is generated with a hash function on some local identifiers (host, process, thread) and the hash value is large enough to reduce the probability of collisions without the need for a shared central authority.</p><p name="9d5b" id="9d5b" class="graf graf--p graf-after--p">However, in the context of Oracle Database:</p><ul class="postList"><li name="db97" id="db97" class="graf graf--li graf-after--p">having a shared object is not a problem, as we have a database</li><li name="dfcf" id="dfcf" class="graf graf--li graf-after--li">large values are less efficient (more space in disk, memory and more CPU to process)</li></ul><h3 name="1965" id="1965" class="graf graf--h3 graf-after--li">NUMBER from SEQUENCE</h3><p name="3a3b" id="3a3b" class="graf graf--p graf-after--h3">In order to put some numbers about this argument, I create a 10 million rows table with an ID generated from a SEQUENCE:</p><pre name="7338" id="7338" class="graf graf--pre graf-after--p">SQL&gt; create sequence DEMO_NUM_ID cache 1e6;<br>Sequence DEMO_NUM_ID created.</pre><pre name="9d61" id="9d61" class="graf graf--pre graf-after--pre">SQL&gt; create table DEMO_NUM<br>     (ID constraint DEMO_NUM_ID primary key, NUM) <br>     as select <strong class="markup--strong markup--pre-strong">DEMO_NUM_ID.nextval</strong>, rownum <br>     from xmltable(&#39;1 to 10000000&#39;);</pre><pre name="2cba" id="2cba" class="graf graf--pre graf-after--pre">Table DEMO_NUM created.<br>Elapsed: 00:04:37.796</pre><p name="8c1d" id="8c1d" class="graf graf--p graf-after--pre">The data type returned by the sequence is a NUMBER:</p><pre name="ecfd" id="ecfd" class="graf graf--pre graf-after--p">SQL&gt; desc DEMO_NUM</pre><pre name="6280" id="6280" class="graf graf--pre graf-after--pre">Name Null?    Type       <br>---- -------- ---------- <br>ID   NOT NULL <strong class="markup--strong markup--pre-strong">NUMBER(38)</strong> <br>NUM           NUMBER</pre><p name="40de" id="40de" class="graf graf--p graf-after--pre">A NUMBER stores two digits per bytes. Here, my 10 million values take on average less than 5 bytes:</p><pre name="dc93" id="dc93" class="graf graf--pre graf-after--p">SQL&gt; select sum(<strong class="markup--strong markup--pre-strong">vsize</strong>(ID))/count(*),max(ID),count(*) from DEMO_NUM;</pre><pre name="6981" id="6981" class="graf graf--pre graf-after--pre">SUM(VSIZE(ID))/COUNT(*)    MAX(ID)   COUNT(*)<br>----------------------- ---------- ----------<br>              <strong class="markup--strong markup--pre-strong">4.8</strong>888893   10000000   10000000</pre><p name="c39c" id="c39c" class="graf graf--p graf-after--pre">This is very efficient. It is even smaller than a ROWID which is the internal identification of a row.</p><h3 name="2f3b" id="2f3b" class="graf graf--h3 graf-after--p">UUID from SYS_GUID()</h3><p name="5219" id="5219" class="graf graf--p graf-after--h3">Here is a similar table with the ID generated as a GUID:</p><pre name="bcff" id="bcff" class="graf graf--pre graf-after--p">SQL&gt; create table DEMO_GUID<br>     (ID constraint DEMO_GUID_ID primary key, NUM) <br>     as select <strong class="markup--strong markup--pre-strong">sys_guid()</strong>, rownum <br>     from xmltable(&#39;1 to 10000000&#39;);</pre><pre name="7ea8" id="7ea8" class="graf graf--pre graf-after--pre">Table DEMO_GUID created.<br>Elapsed: 00:05:45.900</pre><p name="d408" id="d408" class="graf graf--p graf-after--pre">You can already see that it takes longer to generate. This generates a RAW datatype in 16 bytes.</p><pre name="3671" id="3671" class="graf graf--pre graf-after--p">SQL&gt; desc DEMO_GUID<br>Name Null?    Type         <br>---- -------- ------------ <br>ID   NOT NULL <strong class="markup--strong markup--pre-strong">RAW(16 BYTE)</strong> <br>NUM           NUMBER</pre><p name="fdee" id="fdee" class="graf graf--p graf-after--pre">This is very large. Each row where it is a primary key, and each foreign key, and indexes on them, will take 16 bytes where a large part is always the same (hashed from the host, and process). Note that a RAW is displayed with its hexadecimal character translation which is 32 characters here, but does not store it as a VARCHAR2(32) as this will be 2 times larger, and has some additional processing for characterset.</p><p name="5463" id="5463" class="graf graf--p graf-after--p">No surprise here, each value is 16 bytes:</p><pre name="3476" id="3476" class="graf graf--pre graf-after--p">SQL&gt; select sum(vsize(ID))/count(*) from DEMO_GUID;</pre><pre name="469c" id="469c" class="graf graf--pre graf-after--pre">SUM(VSIZE(ID))/COUNT(*)<br>-----------------------<br>                     16</pre><h3 name="c5df" id="c5df" class="graf graf--h3 graf-after--pre">RAW from NUMBER</h3><p name="8cad" id="8cad" class="graf graf--p graf-after--h3">I see only one advantage in GUID primary keys: they are RAW datatypes. I like it because we don’t want arithmetic operations on it. And in addition to that nobody will complain about gaps in numbering. Then, can we store our NUMBER from the sequence as a ROW?</p><p name="6b43" id="6b43" class="graf graf--p graf-after--p">Here, I’m converting to a varchar2 hexadecimal and then to a raw. There’s probably a more efficient method to convert a number to a binary row. UTL_RAW has a CAST_FROM_NUMBER but that is the NUMBER representation. There’s also a CAST_FROM_BINARY_INTEGER. Here, I did a simple conversion through a varchar2, not very nice but the execution time is correct.</p><pre name="7d5f" id="7d5f" class="graf graf--pre graf-after--p">SQL&gt; create sequence DEMO_RAW_ID cache 1e6;<br>Sequence DEMO_RAW_ID created.</pre><pre name="0de4" id="0de4" class="graf graf--pre graf-after--pre">SQL&gt; create table DEMO_RAW <br>     (ID constraint DEMO_RAW_ID primary key, NUM) <br>     as select <strong class="markup--strong markup--pre-strong">hextoraw</strong>(<strong class="markup--strong markup--pre-strong">to_char</strong>(DEMO_RAW_ID.nextval,rpad(&#39;FM&#39;,65,&#39;<strong class="markup--strong markup--pre-strong">X</strong>&#39;)))<br>     , rownum<br>     from xmltable(&#39;1 to 10000000&#39;);</pre><pre name="c104" id="c104" class="graf graf--pre graf-after--pre">Table DEMO_RAW created.<br>Elapsed: 00:04:21.259</pre><p name="eabb" id="eabb" class="graf graf--p graf-after--pre">This storage is even smaller than the NUMBER. 3 bytes instead of 5 bytes on average for those 10 million values:</p><pre name="7686" id="7686" class="graf graf--pre graf-after--p">SQL&gt; select * from <br>     (select sum(vsize(ID))/count(*) &quot;vsize(NUM)&quot; from DEMO_NUM),<br>     (select sum(vsize(ID))/count(*) &quot;vsize(RAW)&quot; from DEMO_RAW),<br>     (select sum(vsize(ID))/count(*) &quot;vsize(GUID)&quot; from DEMO_GUID);</pre><pre name="bd4e" id="bd4e" class="graf graf--pre graf-after--pre">vsize(NUM) vsize(RAW) vsize(GUID)<br>---------- ---------- -----------<br> 4.8888893   <strong class="markup--strong markup--pre-strong">2.9</strong>93421          16</pre><p name="5874" id="5874" class="graf graf--p graf-after--pre">This is totally expected as a byte can store 255 different values, but NUMBER uses only 99 ones with the two digits representation. In my opinion, it would make sense to have a SEQUENCE returning an integer as a RAW binary representation. But as I don’t think people will actually use it, I will not fill an Enhancement Request for that.</p><p name="7d51" id="7d51" class="graf graf--p graf-after--p">Here is the size for the tables and the index on this ID column:</p><pre name="a0e4" id="a0e4" class="graf graf--pre graf-after--p">SQL&gt; select segment_name,segment_type,bytes/1024/1024 MBytes <br>     from dba_segments <br>     where owner=user and segment_name like &#39;DEMO%&#39; order by mbytes;</pre><pre name="ebe7" id="ebe7" class="graf graf--pre graf-after--pre">SEGMENT_NAME                   SEGMENT_TYPE           MBYTES<br>------------------------------ ------------------ ----------<br>DEMO_RAW_ID                    INDEX                     160<br>DEMO_RAW                       TABLE                     168<br>DEMO_NUM_ID                    INDEX                     174<br>DEMO_NUM                       TABLE                     188<br><strong class="markup--strong markup--pre-strong">DEMO_GUID_ID                   INDEX                     296<br>DEMO_GUID                      TABLE                     304</strong></pre><p name="174f" id="174f" class="graf graf--p graf-after--pre">Of course, this confirms what we have seen with the average size. The GUID is definitely not a good solution.</p><h3 name="3e43" id="3e43" class="graf graf--h3 graf-after--p">Compression</h3><p name="105f" id="105f" class="graf graf--p graf-after--h3">12cR2 introduced a compression algorithm for indexes which is interesting even when there are no repeated column values: ADVANCED HIGH (which is available in Enterprise Edition with Advanced Compression Option):</p><pre name="5a44" id="5a44" class="graf graf--pre graf-after--p">SQL&gt; alter index DEMO_GUID_ID rebuild compress advanced high;</pre><pre name="75b0" id="75b0" class="graf graf--pre graf-after--pre">Index DEMO_GUID_ID altered.<br>Elapsed: 00:01:30.035</pre><pre name="c2be" id="c2be" class="graf graf--pre graf-after--pre">SQL&gt; alter index DEMO_RAW_ID rebuild compress advanced high;</pre><pre name="d77a" id="d77a" class="graf graf--pre graf-after--pre">Index DEMO_RAW_ID altered.<br>Elapsed: 00:00:57.193</pre><pre name="6ede" id="6ede" class="graf graf--pre graf-after--pre">SQL&gt; alter index DEMO_NUM_ID rebuild compress advanced high;</pre><pre name="5b35" id="5b35" class="graf graf--pre graf-after--pre">Index DEMO_NUM_ID altered.<br>Elapsed: 00:00:49.574</pre><p name="f8e5" id="f8e5" class="graf graf--p graf-after--pre">This reduced all 3 indexes. But the GUID one is still the largest one even if a large part of the values are repeated.</p><pre name="6d35" id="6d35" class="graf graf--pre graf-after--p">SQL&gt; select segment_name,segment_type,bytes/1024/1024 MBytes from dba_segments where owner=user and segment_name like &#39;DEMO%&#39; order by mbytes;</pre><pre name="b308" id="b308" class="graf graf--pre graf-after--pre">SEGMENT_NAME                   SEGMENT_TYPE           MBYTES<br>------------------------------ ------------------ ----------<br>DEMO_RAW_ID                    INDEX                      80<br>DEMO_NUM_ID                    INDEX                      80<br>DEMO_GUID_ID                   INDEX                     136<br>DEMO_RAW                       TABLE                     168<br>DEMO_NUM                       TABLE                     188<br>DEMO_GUID                      TABLE                     304</pre><p name="c3ec" id="c3ec" class="graf graf--p graf-after--pre">It is interesting to see that the benefit of RAW number vs. NUMBER datatype is smaller once compressed.</p><h3 name="c2a2" id="c2a2" class="graf graf--h3 graf-after--p">When is GUID smaller than a NUMBER?</h3><p name="52ee" id="52ee" class="graf graf--p graf-after--h3">Here is where a NUMBER starts to be larger than a 16 bytes GUID:</p><figure name="949a" id="949a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 353px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50.5%;"></div><img class="graf-image" data-image-id="1*1y2vahTbf3f4VUhsRgVwVg.png" data-width="1537" data-height="776" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*1y2vahTbf3f4VUhsRgVwVg.png"></div></figure><p name="927d" id="927d" class="graf graf--p graf-after--figure">1E30+1 is the first number that reaches 17 bytes. You will never reach this number with a sequence. Just calculate the size of a database storing these numbers — even with huge gaps in the sequences. That’s impossible. And anyway, GUID is not a solution there given the high probability of collisions.</p><h4 name="feab" id="feab" class="graf graf--h4 graf-after--p">In summary: do not use GUID or UUID for your primary keys.</h4><p name="ea69" id="ea69" class="graf graf--p graf-after--h4 graf--trailing">A NUMBER generated from a SEQUENCE is the right/efficient/scalable way to get a unique identifier. And if you want to be sure to have no collision when merging or replicating from another system, then just add another ‘system identifier’ as an additional column in the primary key. This can be a node number in a distributed system, or a 3-letter identifier of the company. When column values have a repeated subset, there’s no efficient deduplication or compression techniques. But when it is a different column that is fully repeated, table and index compression can be used. So, if you really need to add a hashed hostname, put it in an additional column rather than the UUID idea of mixing all in one value.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/ab11aa7dbfe7"><time class="dt-published" datetime="2018-12-31T15:24:52.682Z">December 31, 2018</time></a>.</p><p><a href="https://medium.com/@FranckPachot/uuid-aka-guid-vs-oracle-sequence-number-ab11aa7dbfe7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>