<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Oracle global vs. partition level statistics CBO usage</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Oracle global vs. partition level statistics CBO usage</h1>
</header>
<section data-field="subtitle" class="p-summary">
Global statistics are complex to gather. Gathering on the whole table can be very long and doesn’t ‘scale’ because the duration will…
</section>
<section data-field="body" class="e-content">
<section name="106f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="074a" id="074a" class="graf graf--h3 graf--leading graf--title">Oracle global vs. partition level statistics CBO usage</h3><p name="a2eb" id="a2eb" class="graf graf--p graf-after--h3">Global statistics are complex to gather. Gathering on the whole table can be very long and doesn’t ‘scale’ because the duration will increase with the volume. Incremental gathering can be a solution but has its side effects (such as the size of the synopsis). But having stale global statistics can be dangerous. Do you know when the optimizer bases its estimation on global or on partition level statistics? The partition level statistics are used only:</p><ul class="postList"><li name="af77" id="af77" class="graf graf--li graf-after--p">when partition pruning iterates on only one single partition</li><li name="6d59" id="6d59" class="graf graf--li graf-after--li">when this partition is known at optimization time during the parse phase</li></ul><p name="21a5" id="21a5" class="graf graf--p graf-after--li">This is clearly explained in Jonathan Lewis ‘Cost-Based Oracle Fundamentals’:</p><div name="c725" id="c725" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://books.google.ch/books?id=RyhD1xfENXYC&amp;lpg=PA36&amp;ots=bpUNUkVscm&amp;dq=%22So%2C%20with%20a%20known%20single%20partition%20at%20parse%20time%2C%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;pg=PA36#v=onepage&amp;q=%22So,%20with%20a%20known%20single%20partition%20at%20parse%20time,%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;f=false" data-href="https://books.google.ch/books?id=RyhD1xfENXYC&amp;lpg=PA36&amp;ots=bpUNUkVscm&amp;dq=%22So%2C%20with%20a%20known%20single%20partition%20at%20parse%20time%2C%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;pg=PA36#v=onepage&amp;q=%22So,%20with%20a%20known%20single%20partition%20at%20parse%20time,%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;f=false" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://books.google.ch/books?id=RyhD1xfENXYC&amp;lpg=PA36&amp;ots=bpUNUkVscm&amp;dq=%22So%2C%20with%20a%20known%20single%20partition%20at%20parse%20time%2C%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;pg=PA36#v=onepage&amp;q=%22So,%20with%20a%20known%20single%20partition%20at%20parse%20time,%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;f=false"><strong class="markup--strong markup--mixtapeEmbed-strong">Cost-Based Oracle Fundamentals</strong><br><em class="markup--em markup--mixtapeEmbed-em">Arthur C. Clarke once wrote that &quot;any sufficiently advanced technology is indistinguishable from magic. &quot; I believe…</em>books.google.ch</a><a href="https://books.google.ch/books?id=RyhD1xfENXYC&amp;lpg=PA36&amp;ots=bpUNUkVscm&amp;dq=%22So%2C%20with%20a%20known%20single%20partition%20at%20parse%20time%2C%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;pg=PA36#v=onepage&amp;q=%22So,%20with%20a%20known%20single%20partition%20at%20parse%20time,%20Oracle%20has%20used%20the%20partition-level%20statistics.%22&amp;f=false" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="eda8fe8c619481d9dcc86aa6b0472034" data-thumbnail-img-id="0*7t9FF-ubHuYQfcl3" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*7t9FF-ubHuYQfcl3);"></a></div><p name="9302" id="9302" class="graf graf--p graf-after--mixtapeEmbed">I also tested on the current release (18c) to verify this. Here is the test-case.</p><p name="7984" id="7984" class="graf graf--p graf-after--p">I create a table partitioned by year, fill 100 rows in one partition and 5000 rows in another. Then I gather the statistics:</p><pre name="0ef5" id="0ef5" class="graf graf--pre graf-after--p">SQL&gt; create table DEMO (day date) partition by range(day) (<br>     partition P2018 values less than (date &#39;2019-01-01&#39;),<br>     partition P2019 values less than (date &#39;2020-01-01&#39;),<br>     partition P2020 values less than (date &#39;2021-01-01&#39;),<br>     partition P2021 values less than (date &#39;2022-01-01&#39;)<br>    );</pre><pre name="e70e" id="e70e" class="graf graf--pre graf-after--pre">Table DEMO created.</pre><pre name="2cd1" id="2cd1" class="graf graf--pre graf-after--pre">SQL&gt; insert into DEMO <br>     select date &#39;2019-01-01&#39;+rownum from xmltable(&#39;1 to 100&#39;);</pre><pre name="f520" id="f520" class="graf graf--pre graf-after--pre">100 rows inserted.</pre><pre name="a194" id="a194" class="graf graf--pre graf-after--pre">SQL&gt; insert into DEMO <br>     select date &#39;2018-01-01&#39;-rownum/24 from xmltable(&#39;1 to 5000&#39;);</pre><pre name="537f" id="537f" class="graf graf--pre graf-after--pre">5,000 rows inserted.</pre><pre name="346d" id="346d" class="graf graf--pre graf-after--pre">SQL&gt; exec dbms_stats.gather_table_stats(user,&#39;DEMO&#39;);</pre><pre name="dc01" id="dc01" class="graf graf--pre graf-after--pre">PL/SQL procedure successfully completed.</pre><p name="f3e3" id="f3e3" class="graf graf--p graf-after--pre">My goal is to show when the partition or the global statistics are used.</p><p name="d2b9" id="d2b9" class="graf graf--p graf-after--p">Here are the statistics:</p><pre name="755c" id="755c" class="graf graf--pre graf-after--p">SQL&gt; select partition_name,object_type,num_rows,global_stats <br>   ,to_date((regexp_replace(<br>     extract(dbms_xmlgen.getxmltype(<br>     &#39;select high_value from dba_tab_partitions <br>      where table_owner=&#39;&#39;&#39;||owner||&#39;&#39;&#39; <br>      and table_name=&#39;&#39;&#39;||table_name||&#39;&#39;&#39; <br>      and partition_name=&#39;&#39;&#39;||partition_name||&#39;&#39;&#39;&#39;<br>     ),&#39;/ROWSET/ROW/HIGH_VALUE/text()&#39;).getstringval()<br>     ,&#39;[^;]*apos; *([^;]*) *[^;]apos;.*&#39;,&#39;\1&#39;))<br>    ,&#39;yyyy-mm-dd hh24:mi:ss&#39;) high_value<br>   from dba_tab_statistics <br>   where owner=user and table_name=&#39;DEMO&#39; order by 1 nulls first;</pre><pre name="f9c4" id="f9c4" class="graf graf--pre graf-after--pre">PARTITION_ OBJECT_TYPE    <strong class="markup--strong markup--pre-strong">NUM_ROWS</strong> GLO HIGH_VALUE <br>---------- ------------ ---------- --- -----------<br>           <strong class="markup--strong markup--pre-strong">TABLE</strong>              <strong class="markup--strong markup--pre-strong">5100</strong> YES            <br>P2018      PARTITION          5000 YES 01-JAN-2019<br>P2019      <strong class="markup--strong markup--pre-strong">PARTITION</strong>           <strong class="markup--strong markup--pre-strong">100</strong> YES 01-JAN-2020<br>P2020      PARTITION             0 YES 01-JAN-2021<br>P2021      PARTITION             0 YES 01-JAN-2022</pre><p name="53e9" id="53e9" class="graf graf--p graf-after--pre">I’ll query partitions above 2019 where I have 100 rows. But the global statistics count 5100 rows. Let’s see which one is used.</p><h4 name="14ca" id="14ca" class="graf graf--h4 graf-after--p">Pstart = Pstop (PARTITION RANGE SINGLE) -&gt; partition</h4><p name="a78a" id="a78a" class="graf graf--p graf-after--h4">This first query reads the rows from only one partition, and the optimizer knows it at parse time because I use literals:</p><pre name="1a2b" id="1a2b" class="graf graf--pre graf-after--p">SQL&gt; select count(*) from DEMO where day between to_date( &#39;2019-01-08&#39;,&#39;yyyy-mm-dd&#39; ) and to_date( &#39;2019-02-08&#39;,&#39;yyyy-mm-dd&#39; ) ;</pre><pre name="12d0" id="12d0" class="graf graf--pre graf-after--pre">COUNT(*)<br>----------<br>        32</pre><pre name="0cc2" id="0cc2" class="graf graf--pre graf-after--pre">SQL&gt; select * from dbms_xplan.display_cursor(<br>     format=&gt;&#39;basic +rows +outline +peeked_binds +partition&#39;);</pre><pre name="cdad" id="cdad" class="graf graf--pre graf-after--pre">PLAN_TABLE_OUTPUT                                                   <br>--------------------------------------------------------------------<br>EXPLAINED SQL STATEMENT:<br>------------------------<br>select count(*) from DEMO <br> where day between to_date( &#39;<strong class="markup--strong markup--pre-strong">2019</strong>-01-08&#39;,&#39;yyyy-mm-dd&#39; ) <br> and to_date( &#39;<strong class="markup--strong markup--pre-strong">2019</strong>-02-08&#39;,&#39;yyyy-mm-dd&#39; )<br> <br>Plan hash value: 849908795<br> <br>----------------------------------------------------------------<br>| Id  | Operation               | Name | Rows  | <strong class="markup--strong markup--pre-strong">Pstart</strong>| <strong class="markup--strong markup--pre-strong">Pstop </strong>|<br>----------------------------------------------------------------<br>|   0 | SELECT STATEMENT        |      |       |       |       |<br>|   1 |  SORT AGGREGATE         |      |     1 |       |       |<br>|   2 |   PARTITION RANGE <strong class="markup--strong markup--pre-strong">SINGLE</strong>|      |    33 |     2 |     2 |<br>|   3 |    TABLE ACCESS FULL    | DEMO |    <strong class="markup--strong markup--pre-strong">33 </strong>|     <strong class="markup--strong markup--pre-strong">2</strong> |     <strong class="markup--strong markup--pre-strong">2</strong> |<br>----------------------------------------------------------------</pre><ul class="postList"><li name="bfbc" id="bfbc" class="graf graf--li graf-after--pre">Partition-level statistics are used when only one partition is accessed, known at the time of parsing. You see that with <em class="markup--em markup--li-em">Pstart</em>=<em class="markup--em markup--li-em">Pstop </em>=<em class="markup--em markup--li-em"> number</em>.</li></ul><h4 name="721c" id="721c" class="graf graf--h4 graf-after--li">Pstart &lt;&gt; Pstop (PARTITION RANGE ITERATOR/FULL) -&gt; global</h4><p name="ca51" id="ca51" class="graf graf--p graf-after--h4">The second query still knows the partitions are parse time, but multiple partitions are concerned:</p><pre name="9882" id="9882" class="graf graf--pre graf-after--p">SQL&gt; select count(*) from DEMO where day between to_date( &#39;2019-01-08&#39;,&#39;yyyy-mm-dd&#39; ) and to_date( &#39;2020-02-08&#39;,&#39;yyyy-mm-dd&#39; );</pre><pre name="a3a1" id="a3a1" class="graf graf--pre graf-after--pre">COUNT(*)<br>----------<br>        94</pre><pre name="5183" id="5183" class="graf graf--pre graf-after--pre">SQL&gt; select * from dbms_xplan.display_cursor(<br>     format=&gt;&#39;basic +rows +outline +peeked_binds +partition&#39;);</pre><pre name="8475" id="8475" class="graf graf--pre graf-after--pre">PLAN_TABLE_OUTPUT                                                   <br>--------------------------------------------------------------------<br>EXPLAINED SQL STATEMENT:<br>------------------------<br>select count(*) from DEMO <br> where day between to_date( &#39;<strong class="markup--strong markup--pre-strong">2019</strong>-01-08&#39;,&#39;yyyy-mm-dd&#39; ) <br> and to_date( &#39;<strong class="markup--strong markup--pre-strong">2020</strong>-02-08&#39;,&#39;yyyy-mm-dd&#39; )<br> <br>Plan hash value: 1988821877<br> <br>------------------------------------------------------------------<br>| Id  | Operation                 | Name | Rows  | <strong class="markup--strong markup--pre-strong">Pstart</strong>| <strong class="markup--strong markup--pre-strong">Pstop</strong> |<br>------------------------------------------------------------------<br>|   0 | SELECT STATEMENT          |      |       |       |       |<br>|   1 |  SORT AGGREGATE           |      |     1 |       |       |<br>|   2 |   PARTITION RANGE <strong class="markup--strong markup--pre-strong">ITERATOR</strong>|      |   705 |     2 |     3 |<br>|   3 |    TABLE ACCESS FULL      | DEMO |   <strong class="markup--strong markup--pre-strong">705</strong> |     <strong class="markup--strong markup--pre-strong">2</strong> |     <strong class="markup--strong markup--pre-strong">3</strong> |<br>------------------------------------------------------------------</pre><p name="df75" id="df75" class="graf graf--p graf-after--pre">This high estimation comes from the high number known at the table level.</p><ul class="postList"><li name="006d" id="006d" class="graf graf--li graf-after--p">Global table level statistics are used when more than one partition is accessed, even when they are known at the time of parsing. You see that with <em class="markup--em markup--li-em">Pstart</em> &lt;&gt; <em class="markup--em markup--li-em">Pstop</em>.</li></ul><h4 name="bfaa" id="bfaa" class="graf graf--h4 graf-after--li">KEY — KEY (PARTITION RANGE ITERATOR/FULL) -&gt; global</h4><p name="a40a" id="a40a" class="graf graf--p graf-after--h4">For the third query, I use bind variables and set them to access only one partition:</p><pre name="f72c" id="f72c" class="graf graf--pre graf-after--p">SQL&gt; variable d1 varchar2(10)<br>SQL&gt; variable d2 varchar2(10)<br>SQL&gt; exec <strong class="markup--strong markup--pre-strong">:d1</strong>:=&#39;<strong class="markup--strong markup--pre-strong">2019</strong>-01-08&#39; ; <strong class="markup--strong markup--pre-strong">:d2</strong>:=&#39;<strong class="markup--strong markup--pre-strong">2019</strong>-02-08&#39;</pre><pre name="3727" id="3727" class="graf graf--pre graf-after--pre">PL/SQL procedure successfully completed.</pre><pre name="e7d7" id="e7d7" class="graf graf--pre graf-after--pre">SQL&gt; select count(*) from DEMO where day between to_date( :d1,&#39;yyyy-mm-dd&#39; ) and to_date( :d2,&#39;yyyy-mm-dd&#39; );</pre><pre name="5cdd" id="5cdd" class="graf graf--pre graf-after--pre">COUNT(*)<br>----------<br>        32</pre><pre name="44e8" id="44e8" class="graf graf--pre graf-after--pre">SQL&gt; select * from dbms_xplan.display_cursor(<br>     format=&gt;&#39;basic +rows +outline +peeked_binds +partition&#39;);</pre><pre name="3c13" id="3c13" class="graf graf--pre graf-after--pre">PLAN_TABLE_OUTPUT                                                   <br>--------------------------------------------------------------------<br>EXPLAINED SQL STATEMENT:<br>------------------------<br>select count(*) from DEMO <br> where day between to_date( <strong class="markup--strong markup--pre-strong">:d1</strong>,&#39;yyyy-mm-dd&#39; ) <br> and to_date( <strong class="markup--strong markup--pre-strong">:d2</strong>,&#39;yyyy-mm-dd&#39; )<br> <br>Plan hash value: 203823535<br> <br>-------------------------------------------------------------------<br>| Id  | Operation                  | Name | Rows  | Pstart| Pstop |<br>-------------------------------------------------------------------<br>|   0 | SELECT STATEMENT           |      |       |       |       |<br>|   1 |  SORT AGGREGATE            |      |     1 |       |       |<br>|   2 |   FILTER                   |      |       |       |       |<br>|   3 |    PARTITION RANGE <strong class="markup--strong markup--pre-strong">ITERATOR</strong>|      |    33 |   KEY |   KEY |<br>|   4 |     TABLE ACCESS FULL      | DEMO |    <strong class="markup--strong markup--pre-strong">33</strong> |   <strong class="markup--strong markup--pre-strong">KEY</strong> |   <strong class="markup--strong markup--pre-strong">KEY</strong> |<br>-------------------------------------------------------------------<br> <br><br><strong class="markup--strong markup--pre-strong">Peeked Bind</strong>s (identified by position):<br>--------------------------------------<br> <br>   1 - <strong class="markup--strong markup--pre-strong">:D1</strong> (VARCHAR2(30), CSID=873): &#39;<strong class="markup--strong markup--pre-strong">2019</strong>-01-08&#39;<br>   2 - <strong class="markup--strong markup--pre-strong">:D2</strong> (VARCHAR2(30), CSID=873): &#39;<strong class="markup--strong markup--pre-strong">2019</strong>-02-08&#39;</pre><p name="8f61" id="8f61" class="graf graf--p graf-after--pre">The cardinality is estimated correctly: the partition statistics were used.</p><ul class="postList"><li name="d558" id="d558" class="graf graf--li graf-after--p">Partition-level statistics are used when only one partition is accessed, known at the time of parsing, even the value is known with bind peeking. You see that with KEY/KEY for Pstart/Pstop and with bind variables listed by +peeked_binds format</li></ul><p name="0d28" id="0d28" class="graf graf--p graf-after--li">Of course, this accurate estimation has a drawback: executing the query again for another range of dates may re-use the same execution plan. You should code a different statement when you know that you cover something different.</p><h4 name="6c1b" id="6c1b" class="graf graf--h4 graf-after--p">Without bind peeking -&gt; global</h4><p name="d6d1" id="d6d1" class="graf graf--p graf-after--h4">It is not a recommendation, but to avoid the risk mentioned above, some sessions may prefer to disable bind peeking. When bind variable peeking is disabled, the optimization is done before any value is known, so there is no possibility to know which partition is concerned.</p><pre name="3d48" id="3d48" class="graf graf--pre graf-after--p">SQL&gt; alter session set &quot;<strong class="markup--strong markup--pre-strong">_optim_peek_user_binds</strong>&quot;=<strong class="markup--strong markup--pre-strong">false</strong>;</pre><pre name="ada2" id="ada2" class="graf graf--pre graf-after--pre">Session altered.</pre><pre name="dcb6" id="dcb6" class="graf graf--pre graf-after--pre">SQL&gt; select count(*) from DEMO where day between to_date( :d1,&#39;yyyy-mm-dd&#39; ) and to_date( :d2,&#39;yyyy-mm-dd&#39; );</pre><pre name="9d71" id="9d71" class="graf graf--pre graf-after--pre">COUNT(*)<br>----------<br>        32</pre><pre name="ff26" id="ff26" class="graf graf--pre graf-after--pre">SQL&gt; select * from dbms_xplan.display_cursor(<br>     format=&gt;&#39;basic +rows +outline +peeked_binds +partition&#39;);</pre><pre name="5b6e" id="5b6e" class="graf graf--pre graf-after--pre">PLAN_TABLE_OUTPUT                                                   <br>--------------------------------------------------------------------<br>EXPLAINED SQL STATEMENT:<br>------------------------<br>select count(*) from DEMO <br> where day between to_date( <strong class="markup--strong markup--pre-strong">:d1</strong>,&#39;yyyy-mm-dd&#39; )<br> and to_date( <strong class="markup--strong markup--pre-strong">:d2</strong>,&#39;yyyy-mm-dd&#39; )<br> <br>Plan hash value: 203823535<br> <br>-------------------------------------------------------------------<br>| Id  | Operation                  | Name | Rows  | Pstart| Pstop |<br>-------------------------------------------------------------------<br>|   0 | SELECT STATEMENT           |      |       |       |       |<br>|   1 |  SORT AGGREGATE            |      |     1 |       |       |<br>|   2 |   FILTER                   |      |       |       |       |<br>|   3 |    PARTITION RANGE ITERATOR|      |    13 |   KEY |   KEY |<br>|   4 |     TABLE ACCESS FULL      | DEMO |    <strong class="markup--strong markup--pre-strong">13</strong> |   <strong class="markup--strong markup--pre-strong">KEY</strong> |   <strong class="markup--strong markup--pre-strong">KEY</strong> |<br>-------------------------------------------------------------------<br> <br>Outline Data<br>-------------<br> <br>  /*+<br>      BEGIN_OUTLINE_DATA<br>      IGNORE_OPTIM_EMBEDDED_HINTS<br>      OPTIMIZER_FEATURES_ENABLE(&#39;19.1.0&#39;)<br>      DB_VERSION(&#39;19.1.0&#39;)<br>      OPT_PARAM(&#39;<strong class="markup--strong markup--pre-strong">_optim_peek_user_binds</strong>&#39; &#39;<strong class="markup--strong markup--pre-strong">false</strong>&#39;)<br>      ALL_ROWS<br>      OUTLINE_LEAF(@&quot;SEL$1&quot;)<br>      FULL(@&quot;SEL$1&quot; &quot;DEMO&quot;@&quot;SEL$1&quot;)<br>      END_OUTLINE_DATA<br>  */</pre><p name="bb6d" id="bb6d" class="graf graf--p graf-after--pre">Here the optimizer estimates 13/5100≈0.25% of global rows.</p><p name="5485" id="5485" class="graf graf--p graf-after--p">In conclusion, there is only one case where the partition level statistics can be used: partition pruning to one single partition, known at parse time by the literal value or the peeked bind. Then, you cannot ignore global statistics.</p><p name="2a4a" id="2a4a" class="graf graf--p graf-after--p">By the way, why did I use a range between 2019–01–08 and 2019–02–08? Probably to remind you that there’s only one month left for the <a href="https://twitter.com/hashtag/KaaS19?src=hash" data-href="https://twitter.com/hashtag/KaaS19?src=hash" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">#KaaS19</a> Belgium Tech Days …</p><div name="0de0" id="0de0" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://www.techdaysbelgium.be/order-tickets/" data-href="https://www.techdaysbelgium.be/order-tickets/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.techdaysbelgium.be/order-tickets/"><strong class="markup--strong markup--mixtapeEmbed-strong">Order Tickets &quot; Techdays Belgium</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>www.techdaysbelgium.be</a><a href="https://www.techdaysbelgium.be/order-tickets/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2bdcfb5a94fbf57b3e258514f7fd3ef5" data-thumbnail-img-id="0*jkeFysrCb3IL9NAk" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*jkeFysrCb3IL9NAk);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/1c2aa2aa3f32"><time class="dt-published" datetime="2019-01-08T22:37:40.974Z">January 8, 2019</time></a>.</p><p><a href="https://medium.com/@FranckPachot/oracle-global-vs-partition-level-statistics-cbo-usage-1c2aa2aa3f32" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>