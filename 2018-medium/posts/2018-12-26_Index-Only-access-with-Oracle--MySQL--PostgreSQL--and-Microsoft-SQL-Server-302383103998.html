<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Index Only access with Oracle, MySQL, PostgreSQL, and Microsoft SQL Server</title><style>
      * {
        <!--font-family: Georgia, Cambria, "Times New Roman", Times, serif;-->
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Index Only access with Oracle, MySQL, PostgreSQL, and Microsoft SQL Server</h1>
</header>
<section data-field="subtitle" class="p-summary">
In my previous post about the advantages of index access over full table scans, I mentioned covering indexes. This is when an Index Range…
</section>
<section data-field="body" class="e-content">
<section name="48fe" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bf17" id="bf17" class="graf graf--h3 graf--leading graf--title">Index Only access with Oracle, MySQL, PostgreSQL, and Microsoft SQL Server</h3><p name="d66c" id="d66c" class="graf graf--p graf-after--h3">In my <a href="https://medium.com/@FranckPachot/we-still-need-partitions-and-indexes-and-i-will-continue-to-commute-by-train-even-when-c21680956a13" data-href="https://medium.com/@FranckPachot/we-still-need-partitions-and-indexes-and-i-will-continue-to-commute-by-train-even-when-c21680956a13" class="markup--anchor markup--p-anchor" target="_blank">previous post</a> about the advantages of index access over full table scans, I mentioned covering indexes. This is when an Index Range Scan can retrieve all columns without going to the table. Adding to an index all the columns used by the SELECT or WHERE clause is an important tuning technique for queries that are around the inflection point between index access and table full scan. But not all RDBMS are equal. What PostgreSQL calls ‘Index Only’ actually reads the table, except for static data with no concurrent modifications.</p><p name="fc3e" id="fc3e" class="graf graf--p graf-after--p">I’ll show the execution plans for this Index Only access on Oracle, MySQL, PostgreSQL, and MS SQLServer. As my skills on the non-Oracle ones are very limited, do not hesitate to comment if you think something is not correct.</p><h3 name="49c0" id="49c0" class="graf graf--h3 graf-after--p">I create a DEMO table</h3><p name="c8d1" id="c8d1" class="graf graf--p graf-after--h3">As I don’t want to bother with datatypes names. I use CREATE TABLE AS SELECT</p><p name="aa3c" id="aa3c" class="graf graf--p graf-after--p">This works on <strong class="markup--strong markup--p-strong">MySQL</strong> and <strong class="markup--strong markup--p-strong">PostgreSQL</strong>:</p><pre name="cab8" id="cab8" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">create table DEMO</strong> as select 1 A,1 B,1 C union all select 1 A,1 B,1 C</pre><p name="f9e1" id="f9e1" class="graf graf--p graf-after--pre">With <strong class="markup--strong markup--p-strong">Oracle</strong> I need to mention a table and DUAL is there for this goal:</p><pre name="097d" id="097d" class="graf graf--pre graf-after--p">create table DEMO as select 1 A, 1 B, 1 C <strong class="markup--strong markup--pre-strong">from dual</strong> <br>union all select 1 A, 1 B , 1 C <strong class="markup--strong markup--pre-strong">from dual</strong>;</pre><p name="a153" id="a153" class="graf graf--p graf-after--pre">With <strong class="markup--strong markup--p-strong">SQL Server</strong> , no ‘Create Table As Select’, but the INTO syntax is used to mention the table to create:</p><pre name="d6f3" id="d6f3" class="graf graf--pre graf-after--p">select 1 A, 1 B, 1 C <strong class="markup--strong markup--pre-strong">into DEMO</strong> union all select 1 A, 1 B , 1 C;</pre><p name="a7c4" id="a7c4" class="graf graf--p graf-after--pre">This table has 2 rows. I’ll add more rows so that the optimizer/query planner can base its estimations on statistics.</p><h3 name="e030" id="e030" class="graf graf--h3 graf-after--p">Insert rows</h3><p name="bb5f" id="bb5f" class="graf graf--p graf-after--h3">My goal is to query with a predicate ‘where A=2’ returning a small number of rows, as I want to benefit from index access. This works on all databases: insert a lot of (1,1,1) with a cartesian product and a few (2,0,0)</p><pre name="b891" id="b891" class="graf graf--pre graf-after--p">insert into DEMO select 1,1,1 <br> from DEMO a,DEMO b,DEMO c,DEMO d,DEMO e,DEMO f,DEMO g,DEMO h;<br>insert into DEMO values (2,0,0);<br>insert into DEMO select a.A, a.B, a.C from DEMO a;<br>create index DEMO_AB on DEMO(A,B);<br>select A,count(*) from DEMO group by A;</pre><p name="c087" id="c087" class="graf graf--p graf-after--pre">Because this version of Oracle gathers statistics during the CTAS but not for further DML, I delete statistics to rely on dynamic sampling:</p><pre name="ad51" id="ad51" class="graf graf--pre graf-after--p">begin dbms_stats.delete_table_stats(&#39;&#39;,&#39;DEMO&#39;); end;<br>/</pre><h3 name="6142" id="6142" class="graf graf--h3 graf-after--pre">Explain plan</h3><p name="08c5" id="08c5" class="graf graf--p graf-after--h3">For <strong class="markup--strong markup--p-strong">MySQL</strong> I don’t know how to get the execution plan with execution statistics, so I simply used EXPLAIN</p><pre name="6bfb" id="6bfb" class="graf graf--pre graf-after--p">explain select sum(A) from DEMO where A=2;<br>explain select sum(B) from DEMO where A=2;<br>explain select sum(C) from DEMO where A=2;</pre><p name="bebc" id="bebc" class="graf graf--p graf-after--pre">The goal is to show the plan when I select only the column used for access(A), or an additional column found in the index (B) or a column which exists only in the table. The one with B is the one where I expect Index Only access.</p><p name="dd97" id="dd97" class="graf graf--p graf-after--p">For <strong class="markup--strong markup--p-strong">PostgreSQL</strong> the EXPLAIN statement can execute and show execution statistics:</p><pre name="91cb" id="91cb" class="graf graf--pre graf-after--p">explain (analyze,verbose,costs,buffers)<br> select sum(A) from DEMO where A=2;</pre><p name="a880" id="a880" class="graf graf--p graf-after--pre">For SQL Server, this is done with SET STATISTICS PROFILE before running the statements:</p><pre name="0ae9" id="0ae9" class="graf graf--pre graf-after--p">set statistics profile on</pre><p name="16b3" id="16b3" class="graf graf--p graf-after--pre">For Oracle, I used DBMS_XPLAN :</p><pre name="bb92" id="bb92" class="graf graf--pre graf-after--p">select /*+ gather_plan_statistics */ sum(B) from DEMO where A=2;<br>select plan_table_output from dbms_xplan.display_cursor(format=&gt;&#39;allstats last +projection&#39;);</pre><h3 name="74f2" id="74f2" class="graf graf--h3 graf-after--pre">Results</h3><p name="b17c" id="b17c" class="graf graf--p graf-after--h3">I’ve run them with <strong class="markup--strong markup--p-strong">db&lt;&gt;fiddle</strong> so that you can see the exact execution with the link provided.</p><h4 name="a9ff" id="a9ff" class="graf graf--h4 graf-after--p">Oracle 18c</h4><p name="63b0" id="63b0" class="graf graf--p graf-after--h4"><a href="https://dbfiddle.uk/?rdbms=oracle_18&amp;fiddle=400775c8c1a7af79529312b4d3d080c6" data-href="https://dbfiddle.uk/?rdbms=oracle_18&amp;fiddle=400775c8c1a7af79529312b4d3d080c6" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://dbfiddle.uk/?rdbms=oracle_18&amp;fiddle=400775c8c1a7af79529312b4d3d080c6</a></p><p name="e525" id="e525" class="graf graf--p graf-after--p">When I access only A or B there is no need to go to the table with Oracle. This is a true Index Only access.</p><figure name="018f" id="018f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 514px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 73.4%;"></div><img class="graf-image" data-image-id="1*vIr9fifLbybgm2FjFAORsQ.png" data-width="1280" data-height="939" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*vIr9fifLbybgm2FjFAORsQ.png"></div></figure><p name="9af5" id="9af5" class="graf graf--p graf-after--figure">The +PROJECTION format shows which columns are returned by each operation and here it is clear that B comes from the index. No need to go to the table for each index entry.</p><p name="baf5" id="baf5" class="graf graf--p graf-after--p">The last example which selects column C is the only one where Oracle has to access the table:</p><figure name="9782" id="9782" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 331px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47.3%;"></div><img class="graf-image" data-image-id="1*R8xNT-mlN7q0fr0cSq5sUQ.png" data-width="1342" data-height="635" src="https://cdn-images-1.medium.com/max/800/1*R8xNT-mlN7q0fr0cSq5sUQ.png"></div></figure><p name="bc63" id="bc63" class="graf graf--p graf-after--figure">In summary, with Oracle, I have to go to the table only when I need a column from it that is not in the index. This is a very interesting solution when I have a range scan which selects a large number of rows, where accessing rows scattered in the table is expensive, but where the table is too large for a full table scan to be efficient. Then the Index Only access is a solution. This technique is also known as Fat Index (from Tapio Lahdenmaki work).</p><h4 name="7984" id="7984" class="graf graf--h4 graf-after--p">PostgreSQL 11</h4><p name="7adc" id="7adc" class="graf graf--p graf-after--h4"><a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=f674aab989f0bdf0b9972841081e1cac" data-href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=f674aab989f0bdf0b9972841081e1cac" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=f674aab989f0bdf0b9972841081e1cac</a></p><p name="86c1" id="86c1" class="graf graf--p graf-after--p">PostgreSQL, since 9.2, has an access path explicitly called <a href="https://wiki.postgresql.org/wiki/Index-only_scans" data-href="https://wiki.postgresql.org/wiki/Index-only_scans" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Index Only</a> but if you run my example, you will not see it. And even when you query only the column A you will access the table:</p><figure name="05e0" id="05e0" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 299px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 42.8%;"></div><img class="graf-image" data-image-id="1*LOmYh2nX15HspMHR9TC2pw.png" data-width="1384" data-height="592" src="https://cdn-images-1.medium.com/max/800/1*LOmYh2nX15HspMHR9TC2pw.png"></div></figure><p name="ea1a" id="ea1a" class="graf graf--p graf-after--figure">This is just an optimized version of going to the table for each index entry, where a bitmap from index entries is built before scanning the table. The query planner may have chosen Index Only access, but it would be less efficient because - despite its name - Index Only access will finally access to the table rows. You see ‘Heap Fetches’ when it is the case. I <a href="https://blog.dbi-services.com/postgres-vs-oracle-access-paths-ii/" data-href="https://blog.dbi-services.com/postgres-vs-oracle-access-paths-ii/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">blogged about it</a> in the past. The reason is that PostgreSQL MVCC (multi-versioning to be able to read without blocking writes) is at Tuple level, and the index has no information about what is committed or not.</p><p name="7c77" id="7c77" class="graf graf--p graf-after--p">Postgres has a little optimization for this, using the visibility map, but this is maintained asynchronously by the vacuum process. In my db&lt;&gt;fiddle example you will see a real Index Only after a full vacuum:</p><figure name="7d68" id="7d68" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 331px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47.3%;"></div><img class="graf-image" data-image-id="1*RgkE5MuNzizmbg0tjZBjDA.png" data-width="1339" data-height="633" src="https://cdn-images-1.medium.com/max/800/1*RgkE5MuNzizmbg0tjZBjDA.png"></div></figure><p name="3d02" id="3d02" class="graf graf--p graf-after--figure">In summary, PostgreSQL Index Only is really ‘Index Only’ when you see ‘Heap Fetches: 0’ and this means that the ‘fat index’ optimization is possible only for tables with rare modifications and frequent vacuum.</p><h4 name="a705" id="a705" class="graf graf--h4 graf-after--p">MySQL 8.0</h4><p name="4886" id="4886" class="graf graf--p graf-after--h4"><a href="https://dbfiddle.uk/?rdbms=mysql_8.0&amp;fiddle=780df4e2a007bf9607c0711441400b5e" data-href="https://dbfiddle.uk/?rdbms=mysql_8.0&amp;fiddle=780df4e2a007bf9607c0711441400b5e" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://dbfiddle.uk/?rdbms=mysql_8.0&amp;fiddle=780df4e2a007bf9607c0711441400b5e</a></p><p name="920d" id="920d" class="graf graf--p graf-after--p">MySQL with the InnoDB engine is MVCC at block level like Oracle, where versioned index blocks contain the information about the visibility. You can see that when I select column A or B which are in the index, the ‘Extra’ information of the execution plan mentions ‘<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information" data-href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Using Index</a>’ which means that there’s no access to the table:</p><figure name="676f" id="676f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 251px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 35.9%;"></div><img class="graf-image" data-image-id="1*D2BeTeC-xnuqIr2ApHTKew.png" data-width="1513" data-height="543" src="https://cdn-images-1.medium.com/max/800/1*D2BeTeC-xnuqIr2ApHTKew.png"></div></figure><h4 name="4fea" id="4fea" class="graf graf--h4 graf-after--figure">SQL Server 2017</h4><p name="d185" id="d185" class="graf graf--p graf-after--h4"><a href="https://dbfiddle.uk/?rdbms=sqlserver_2017l&amp;fiddle=4e2bc8cb87ffc7c004dff1ddb01d4308" data-href="https://dbfiddle.uk/?rdbms=sqlserver_2017l&amp;fiddle=4e2bc8cb87ffc7c004dff1ddb01d4308" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://dbfiddle.uk/?rdbms=sqlserver_2017l&amp;fiddle=4e2bc8cb87ffc7c004dff1ddb01d4308</a></p><p name="eea2" id="eea2" class="graf graf--p graf-after--p">SQL Server can do Index Only:</p><figure name="9f0a" id="9f0a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 363px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 51.9%;"></div><img class="graf-image" data-image-id="1*T8ib5dnvsEnoqIX-Lf8akw.png" data-width="1874" data-height="973" src="https://cdn-images-1.medium.com/max/800/1*T8ib5dnvsEnoqIX-Lf8akw.png"></div></figure><p name="531d" id="531d" class="graf graf--p graf-after--figure">I can see the difference when selecting the C column which is not in the index. The need to go to the table for each index entry (RID Lookup) makes the optimizer chose a Table Scan for this example (except when hinted):</p><figure name="f24e" id="f24e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 384px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 54.800000000000004%;"></div><img class="graf-image" data-image-id="1*KP4cdplOn2OrlcQa4YmMjw.png" data-width="1737" data-height="952" src="https://cdn-images-1.medium.com/max/800/1*KP4cdplOn2OrlcQa4YmMjw.png"></div></figure><h4 name="e336" id="e336" class="graf graf--h4 graf-after--figure">SQL Lite</h4><p name="4794" id="4794" class="graf graf--p graf-after--h4">As db&lt;&gt;fiddle is down for SQLite when writing this, I’ve run it with <strong class="markup--strong markup--p-strong">sqlfiddle</strong> <a href="http://sqlfiddle.com/#!5/59a60/4" data-href="http://sqlfiddle.com/#!5/59a60/4" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">http://sqlfiddle.com/#!5/59a60/4</a> and I see ‘COVERING’ mentioned when selecting only A or B:</p><pre name="3c89" id="3c89" class="graf graf--pre graf-after--p">SEARCH TABLE DEMO USING <strong class="markup--strong markup--pre-strong">COVERING</strong> INDEX DEMO_AB (A=?)</pre><h3 name="d4fc" id="d4fc" class="graf graf--h3 graf-after--pre">In summary</h3><p name="9225" id="9225" class="graf graf--p graf-after--h3">Oracle and MySQL with InnoDB engine are the ones who can really do Index Only, aka Covering Index, in a high OLTP (where readers do not block writers). SQL Server can also do it, but with reads blocking writes (except with snapshot isolation). PostgreSQL can also do it, with non-blocking reads, but not efficiently when the tables have concurrent modifications.</p><p name="29c3" id="29c3" class="graf graf--p graf-after--p">Of course, my favorite is Oracle as this access path, and the MVCC at block level, is there for decades. Here is Oracle 7.3 execution plan for the same example:</p><figure name="4f2a" id="4f2a" class="graf graf--figure graf-after--p graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 589px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 84.1%;"></div><img class="graf-image" data-image-id="1*E6J3UpyEJlD6NiaeElXVZA.png" data-width="907" data-height="763" src="https://cdn-images-1.medium.com/max/800/1*E6J3UpyEJlD6NiaeElXVZA.png"></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@FranckPachot" class="p-author h-card">Franck Pachot</a> on <a href="https://medium.com/p/302383103998"><time class="dt-published" datetime="2018-12-26T21:32:54.481Z">December 26, 2018</time></a>.</p><p><a href="https://medium.com/@FranckPachot/index-only-access-with-oracle-mysql-postgresql-and-microsoft-sql-server-302383103998" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 27, 2019.</p></footer></article></body></html>